// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/semho/chat-microservices/auth/internal/repository.AuthRepository -o auth_repository_minimock.go -n AuthRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/semho/chat-microservices/auth/internal/client/db"
	"github.com/semho/chat-microservices/auth/internal/model"
)

// AuthRepositoryMock implements repository.AuthRepository
type AuthRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, detail *model.Detail, pass string) (i1 int64, q1 db.Query, err error)
	inspectFuncCreate   func(ctx context.Context, detail *model.Detail, pass string)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mAuthRepositoryMockCreate

	funcCreateLog          func(ctx context.Context, logger *model.Log) (err error)
	inspectFuncCreateLog   func(ctx context.Context, logger *model.Log)
	afterCreateLogCounter  uint64
	beforeCreateLogCounter uint64
	CreateLogMock          mAuthRepositoryMockCreateLog

	funcDelete          func(ctx context.Context, id int64) (q1 db.Query, err error)
	inspectFuncDelete   func(ctx context.Context, id int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mAuthRepositoryMockDelete

	funcGet          func(ctx context.Context, id int64) (up1 *model.User, q1 db.Query, err error)
	inspectFuncGet   func(ctx context.Context, id int64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAuthRepositoryMockGet

	funcGetListLog          func(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error)
	inspectFuncGetListLog   func(ctx context.Context, pageNumber uint64, pageSize uint64)
	afterGetListLogCounter  uint64
	beforeGetListLogCounter uint64
	GetListLogMock          mAuthRepositoryMockGetListLog

	funcUpdate          func(ctx context.Context, updateUser *model.UpdateUserRequest) (q1 db.Query, err error)
	inspectFuncUpdate   func(ctx context.Context, updateUser *model.UpdateUserRequest)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mAuthRepositoryMockUpdate
}

// NewAuthRepositoryMock returns a mock for repository.AuthRepository
func NewAuthRepositoryMock(t minimock.Tester) *AuthRepositoryMock {
	m := &AuthRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mAuthRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*AuthRepositoryMockCreateParams{}

	m.CreateLogMock = mAuthRepositoryMockCreateLog{mock: m}
	m.CreateLogMock.callArgs = []*AuthRepositoryMockCreateLogParams{}

	m.DeleteMock = mAuthRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*AuthRepositoryMockDeleteParams{}

	m.GetMock = mAuthRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*AuthRepositoryMockGetParams{}

	m.GetListLogMock = mAuthRepositoryMockGetListLog{mock: m}
	m.GetListLogMock.callArgs = []*AuthRepositoryMockGetListLogParams{}

	m.UpdateMock = mAuthRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*AuthRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthRepositoryMockCreate struct {
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateExpectation
	expectations       []*AuthRepositoryMockCreateExpectation

	callArgs []*AuthRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// AuthRepositoryMockCreateExpectation specifies expectation struct of the AuthRepository.Create
type AuthRepositoryMockCreateExpectation struct {
	mock    *AuthRepositoryMock
	params  *AuthRepositoryMockCreateParams
	results *AuthRepositoryMockCreateResults
	Counter uint64
}

// AuthRepositoryMockCreateParams contains parameters of the AuthRepository.Create
type AuthRepositoryMockCreateParams struct {
	ctx    context.Context
	detail *model.Detail
	pass   string
}

// AuthRepositoryMockCreateResults contains results of the AuthRepository.Create
type AuthRepositoryMockCreateResults struct {
	i1  int64
	q1  db.Query
	err error
}

// Expect sets up expected params for AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) Expect(ctx context.Context, detail *model.Detail, pass string) *mAuthRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &AuthRepositoryMockCreateParams{ctx, detail, pass}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) Inspect(f func(ctx context.Context, detail *model.Detail, pass string)) *mAuthRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by AuthRepository.Create
func (mmCreate *mAuthRepositoryMockCreate) Return(i1 int64, q1 db.Query, err error) *AuthRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &AuthRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &AuthRepositoryMockCreateResults{i1, q1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the AuthRepository.Create method
func (mmCreate *mAuthRepositoryMockCreate) Set(f func(ctx context.Context, detail *model.Detail, pass string) (i1 int64, q1 db.Query, err error)) *AuthRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the AuthRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mAuthRepositoryMockCreate) When(ctx context.Context, detail *model.Detail, pass string) *AuthRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("AuthRepositoryMock.Create mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &AuthRepositoryMockCreateParams{ctx, detail, pass},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Create return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateExpectation) Then(i1 int64, q1 db.Query, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateResults{i1, q1, err}
	return e.mock
}

// Create implements repository.AuthRepository
func (mmCreate *AuthRepositoryMock) Create(ctx context.Context, detail *model.Detail, pass string) (i1 int64, q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, detail, pass)
	}

	mm_params := AuthRepositoryMockCreateParams{ctx, detail, pass}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.q1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := AuthRepositoryMockCreateParams{ctx, detail, pass}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("AuthRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the AuthRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).q1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, detail, pass)
	}
	mmCreate.t.Fatalf("Unexpected call to AuthRepositoryMock.Create. %v %v %v", ctx, detail, pass)
	return
}

// CreateAfterCounter returns a count of finished AuthRepositoryMock.Create invocations
func (mmCreate *AuthRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of AuthRepositoryMock.Create invocations
func (mmCreate *AuthRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mAuthRepositoryMockCreate) Calls() []*AuthRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to AuthRepositoryMock.Create")
	}
}

type mAuthRepositoryMockCreateLog struct {
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateLogExpectation
	expectations       []*AuthRepositoryMockCreateLogExpectation

	callArgs []*AuthRepositoryMockCreateLogParams
	mutex    sync.RWMutex
}

// AuthRepositoryMockCreateLogExpectation specifies expectation struct of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogExpectation struct {
	mock    *AuthRepositoryMock
	params  *AuthRepositoryMockCreateLogParams
	results *AuthRepositoryMockCreateLogResults
	Counter uint64
}

// AuthRepositoryMockCreateLogParams contains parameters of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogParams struct {
	ctx    context.Context
	logger *model.Log
}

// AuthRepositoryMockCreateLogResults contains results of the AuthRepository.CreateLog
type AuthRepositoryMockCreateLogResults struct {
	err error
}

// Expect sets up expected params for AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) Expect(ctx context.Context, logger *model.Log) *mAuthRepositoryMockCreateLog {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &AuthRepositoryMockCreateLogExpectation{}
	}

	mmCreateLog.defaultExpectation.params = &AuthRepositoryMockCreateLogParams{ctx, logger}
	for _, e := range mmCreateLog.expectations {
		if minimock.Equal(e.params, mmCreateLog.defaultExpectation.params) {
			mmCreateLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateLog.defaultExpectation.params)
		}
	}

	return mmCreateLog
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) Inspect(f func(ctx context.Context, logger *model.Log)) *mAuthRepositoryMockCreateLog {
	if mmCreateLog.mock.inspectFuncCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CreateLog")
	}

	mmCreateLog.mock.inspectFuncCreateLog = f

	return mmCreateLog
}

// Return sets up results that will be returned by AuthRepository.CreateLog
func (mmCreateLog *mAuthRepositoryMockCreateLog) Return(err error) *AuthRepositoryMock {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	if mmCreateLog.defaultExpectation == nil {
		mmCreateLog.defaultExpectation = &AuthRepositoryMockCreateLogExpectation{mock: mmCreateLog.mock}
	}
	mmCreateLog.defaultExpectation.results = &AuthRepositoryMockCreateLogResults{err}
	return mmCreateLog.mock
}

// Set uses given function f to mock the AuthRepository.CreateLog method
func (mmCreateLog *mAuthRepositoryMockCreateLog) Set(f func(ctx context.Context, logger *model.Log) (err error)) *AuthRepositoryMock {
	if mmCreateLog.defaultExpectation != nil {
		mmCreateLog.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CreateLog method")
	}

	if len(mmCreateLog.expectations) > 0 {
		mmCreateLog.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CreateLog method")
	}

	mmCreateLog.mock.funcCreateLog = f
	return mmCreateLog.mock
}

// When sets expectation for the AuthRepository.CreateLog which will trigger the result defined by the following
// Then helper
func (mmCreateLog *mAuthRepositoryMockCreateLog) When(ctx context.Context, logger *model.Log) *AuthRepositoryMockCreateLogExpectation {
	if mmCreateLog.mock.funcCreateLog != nil {
		mmCreateLog.mock.t.Fatalf("AuthRepositoryMock.CreateLog mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateLogExpectation{
		mock:   mmCreateLog.mock,
		params: &AuthRepositoryMockCreateLogParams{ctx, logger},
	}
	mmCreateLog.expectations = append(mmCreateLog.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CreateLog return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateLogExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateLogResults{err}
	return e.mock
}

// CreateLog implements repository.AuthRepository
func (mmCreateLog *AuthRepositoryMock) CreateLog(ctx context.Context, logger *model.Log) (err error) {
	mm_atomic.AddUint64(&mmCreateLog.beforeCreateLogCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateLog.afterCreateLogCounter, 1)

	if mmCreateLog.inspectFuncCreateLog != nil {
		mmCreateLog.inspectFuncCreateLog(ctx, logger)
	}

	mm_params := AuthRepositoryMockCreateLogParams{ctx, logger}

	// Record call args
	mmCreateLog.CreateLogMock.mutex.Lock()
	mmCreateLog.CreateLogMock.callArgs = append(mmCreateLog.CreateLogMock.callArgs, &mm_params)
	mmCreateLog.CreateLogMock.mutex.Unlock()

	for _, e := range mmCreateLog.CreateLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateLog.CreateLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateLog.CreateLogMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateLog.CreateLogMock.defaultExpectation.params
		mm_got := AuthRepositoryMockCreateLogParams{ctx, logger}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateLog.t.Errorf("AuthRepositoryMock.CreateLog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateLog.CreateLogMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateLog.t.Fatal("No results are set for the AuthRepositoryMock.CreateLog")
		}
		return (*mm_results).err
	}
	if mmCreateLog.funcCreateLog != nil {
		return mmCreateLog.funcCreateLog(ctx, logger)
	}
	mmCreateLog.t.Fatalf("Unexpected call to AuthRepositoryMock.CreateLog. %v %v", ctx, logger)
	return
}

// CreateLogAfterCounter returns a count of finished AuthRepositoryMock.CreateLog invocations
func (mmCreateLog *AuthRepositoryMock) CreateLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.afterCreateLogCounter)
}

// CreateLogBeforeCounter returns a count of AuthRepositoryMock.CreateLog invocations
func (mmCreateLog *AuthRepositoryMock) CreateLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateLog.beforeCreateLogCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CreateLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateLog *mAuthRepositoryMockCreateLog) Calls() []*AuthRepositoryMockCreateLogParams {
	mmCreateLog.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateLogParams, len(mmCreateLog.callArgs))
	copy(argCopy, mmCreateLog.callArgs)

	mmCreateLog.mutex.RUnlock()

	return argCopy
}

// MinimockCreateLogDone returns true if the count of the CreateLog invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateLogDone() bool {
	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLog != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateLogInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateLogInspect() {
	for _, e := range m.CreateLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateLog with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		if m.CreateLogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthRepositoryMock.CreateLog")
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateLog with params: %#v", *m.CreateLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateLog != nil && mm_atomic.LoadUint64(&m.afterCreateLogCounter) < 1 {
		m.t.Error("Expected call to AuthRepositoryMock.CreateLog")
	}
}

type mAuthRepositoryMockDelete struct {
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockDeleteExpectation
	expectations       []*AuthRepositoryMockDeleteExpectation

	callArgs []*AuthRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// AuthRepositoryMockDeleteExpectation specifies expectation struct of the AuthRepository.Delete
type AuthRepositoryMockDeleteExpectation struct {
	mock    *AuthRepositoryMock
	params  *AuthRepositoryMockDeleteParams
	results *AuthRepositoryMockDeleteResults
	Counter uint64
}

// AuthRepositoryMockDeleteParams contains parameters of the AuthRepository.Delete
type AuthRepositoryMockDeleteParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockDeleteResults contains results of the AuthRepository.Delete
type AuthRepositoryMockDeleteResults struct {
	q1  db.Query
	err error
}

// Expect sets up expected params for AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) Expect(ctx context.Context, id int64) *mAuthRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &AuthRepositoryMockDeleteParams{ctx, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by AuthRepository.Delete
func (mmDelete *mAuthRepositoryMockDelete) Return(q1 db.Query, err error) *AuthRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &AuthRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &AuthRepositoryMockDeleteResults{q1, err}
	return mmDelete.mock
}

// Set uses given function f to mock the AuthRepository.Delete method
func (mmDelete *mAuthRepositoryMockDelete) Set(f func(ctx context.Context, id int64) (q1 db.Query, err error)) *AuthRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the AuthRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mAuthRepositoryMockDelete) When(ctx context.Context, id int64) *AuthRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("AuthRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &AuthRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &AuthRepositoryMockDeleteParams{ctx, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Delete return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockDeleteExpectation) Then(q1 db.Query, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockDeleteResults{q1, err}
	return e.mock
}

// Delete implements repository.AuthRepository
func (mmDelete *AuthRepositoryMock) Delete(ctx context.Context, id int64) (q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := AuthRepositoryMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := AuthRepositoryMockDeleteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("AuthRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the AuthRepositoryMock.Delete")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to AuthRepositoryMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished AuthRepositoryMock.Delete invocations
func (mmDelete *AuthRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of AuthRepositoryMock.Delete invocations
func (mmDelete *AuthRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mAuthRepositoryMockDelete) Calls() []*AuthRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to AuthRepositoryMock.Delete")
	}
}

type mAuthRepositoryMockGet struct {
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockGetExpectation
	expectations       []*AuthRepositoryMockGetExpectation

	callArgs []*AuthRepositoryMockGetParams
	mutex    sync.RWMutex
}

// AuthRepositoryMockGetExpectation specifies expectation struct of the AuthRepository.Get
type AuthRepositoryMockGetExpectation struct {
	mock    *AuthRepositoryMock
	params  *AuthRepositoryMockGetParams
	results *AuthRepositoryMockGetResults
	Counter uint64
}

// AuthRepositoryMockGetParams contains parameters of the AuthRepository.Get
type AuthRepositoryMockGetParams struct {
	ctx context.Context
	id  int64
}

// AuthRepositoryMockGetResults contains results of the AuthRepository.Get
type AuthRepositoryMockGetResults struct {
	up1 *model.User
	q1  db.Query
	err error
}

// Expect sets up expected params for AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) Expect(ctx context.Context, id int64) *mAuthRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &AuthRepositoryMockGetParams{ctx, id}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) Inspect(f func(ctx context.Context, id int64)) *mAuthRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by AuthRepository.Get
func (mmGet *mAuthRepositoryMockGet) Return(up1 *model.User, q1 db.Query, err error) *AuthRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AuthRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &AuthRepositoryMockGetResults{up1, q1, err}
	return mmGet.mock
}

// Set uses given function f to mock the AuthRepository.Get method
func (mmGet *mAuthRepositoryMockGet) Set(f func(ctx context.Context, id int64) (up1 *model.User, q1 db.Query, err error)) *AuthRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the AuthRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAuthRepositoryMockGet) When(ctx context.Context, id int64) *AuthRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AuthRepositoryMock.Get mock is already set by Set")
	}

	expectation := &AuthRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &AuthRepositoryMockGetParams{ctx, id},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Get return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockGetExpectation) Then(up1 *model.User, q1 db.Query, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockGetResults{up1, q1, err}
	return e.mock
}

// Get implements repository.AuthRepository
func (mmGet *AuthRepositoryMock) Get(ctx context.Context, id int64) (up1 *model.User, q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := AuthRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.q1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := AuthRepositoryMockGetParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("AuthRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the AuthRepositoryMock.Get")
		}
		return (*mm_results).up1, (*mm_results).q1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to AuthRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished AuthRepositoryMock.Get invocations
func (mmGet *AuthRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of AuthRepositoryMock.Get invocations
func (mmGet *AuthRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAuthRepositoryMockGet) Calls() []*AuthRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to AuthRepositoryMock.Get")
	}
}

type mAuthRepositoryMockGetListLog struct {
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockGetListLogExpectation
	expectations       []*AuthRepositoryMockGetListLogExpectation

	callArgs []*AuthRepositoryMockGetListLogParams
	mutex    sync.RWMutex
}

// AuthRepositoryMockGetListLogExpectation specifies expectation struct of the AuthRepository.GetListLog
type AuthRepositoryMockGetListLogExpectation struct {
	mock    *AuthRepositoryMock
	params  *AuthRepositoryMockGetListLogParams
	results *AuthRepositoryMockGetListLogResults
	Counter uint64
}

// AuthRepositoryMockGetListLogParams contains parameters of the AuthRepository.GetListLog
type AuthRepositoryMockGetListLogParams struct {
	ctx        context.Context
	pageNumber uint64
	pageSize   uint64
}

// AuthRepositoryMockGetListLogResults contains results of the AuthRepository.GetListLog
type AuthRepositoryMockGetListLogResults struct {
	lpa1 []*model.Log
	err  error
}

// Expect sets up expected params for AuthRepository.GetListLog
func (mmGetListLog *mAuthRepositoryMockGetListLog) Expect(ctx context.Context, pageNumber uint64, pageSize uint64) *mAuthRepositoryMockGetListLog {
	if mmGetListLog.mock.funcGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("AuthRepositoryMock.GetListLog mock is already set by Set")
	}

	if mmGetListLog.defaultExpectation == nil {
		mmGetListLog.defaultExpectation = &AuthRepositoryMockGetListLogExpectation{}
	}

	mmGetListLog.defaultExpectation.params = &AuthRepositoryMockGetListLogParams{ctx, pageNumber, pageSize}
	for _, e := range mmGetListLog.expectations {
		if minimock.Equal(e.params, mmGetListLog.defaultExpectation.params) {
			mmGetListLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListLog.defaultExpectation.params)
		}
	}

	return mmGetListLog
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.GetListLog
func (mmGetListLog *mAuthRepositoryMockGetListLog) Inspect(f func(ctx context.Context, pageNumber uint64, pageSize uint64)) *mAuthRepositoryMockGetListLog {
	if mmGetListLog.mock.inspectFuncGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.GetListLog")
	}

	mmGetListLog.mock.inspectFuncGetListLog = f

	return mmGetListLog
}

// Return sets up results that will be returned by AuthRepository.GetListLog
func (mmGetListLog *mAuthRepositoryMockGetListLog) Return(lpa1 []*model.Log, err error) *AuthRepositoryMock {
	if mmGetListLog.mock.funcGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("AuthRepositoryMock.GetListLog mock is already set by Set")
	}

	if mmGetListLog.defaultExpectation == nil {
		mmGetListLog.defaultExpectation = &AuthRepositoryMockGetListLogExpectation{mock: mmGetListLog.mock}
	}
	mmGetListLog.defaultExpectation.results = &AuthRepositoryMockGetListLogResults{lpa1, err}
	return mmGetListLog.mock
}

// Set uses given function f to mock the AuthRepository.GetListLog method
func (mmGetListLog *mAuthRepositoryMockGetListLog) Set(f func(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error)) *AuthRepositoryMock {
	if mmGetListLog.defaultExpectation != nil {
		mmGetListLog.mock.t.Fatalf("Default expectation is already set for the AuthRepository.GetListLog method")
	}

	if len(mmGetListLog.expectations) > 0 {
		mmGetListLog.mock.t.Fatalf("Some expectations are already set for the AuthRepository.GetListLog method")
	}

	mmGetListLog.mock.funcGetListLog = f
	return mmGetListLog.mock
}

// When sets expectation for the AuthRepository.GetListLog which will trigger the result defined by the following
// Then helper
func (mmGetListLog *mAuthRepositoryMockGetListLog) When(ctx context.Context, pageNumber uint64, pageSize uint64) *AuthRepositoryMockGetListLogExpectation {
	if mmGetListLog.mock.funcGetListLog != nil {
		mmGetListLog.mock.t.Fatalf("AuthRepositoryMock.GetListLog mock is already set by Set")
	}

	expectation := &AuthRepositoryMockGetListLogExpectation{
		mock:   mmGetListLog.mock,
		params: &AuthRepositoryMockGetListLogParams{ctx, pageNumber, pageSize},
	}
	mmGetListLog.expectations = append(mmGetListLog.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.GetListLog return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockGetListLogExpectation) Then(lpa1 []*model.Log, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockGetListLogResults{lpa1, err}
	return e.mock
}

// GetListLog implements repository.AuthRepository
func (mmGetListLog *AuthRepositoryMock) GetListLog(ctx context.Context, pageNumber uint64, pageSize uint64) (lpa1 []*model.Log, err error) {
	mm_atomic.AddUint64(&mmGetListLog.beforeGetListLogCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListLog.afterGetListLogCounter, 1)

	if mmGetListLog.inspectFuncGetListLog != nil {
		mmGetListLog.inspectFuncGetListLog(ctx, pageNumber, pageSize)
	}

	mm_params := AuthRepositoryMockGetListLogParams{ctx, pageNumber, pageSize}

	// Record call args
	mmGetListLog.GetListLogMock.mutex.Lock()
	mmGetListLog.GetListLogMock.callArgs = append(mmGetListLog.GetListLogMock.callArgs, &mm_params)
	mmGetListLog.GetListLogMock.mutex.Unlock()

	for _, e := range mmGetListLog.GetListLogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.err
		}
	}

	if mmGetListLog.GetListLogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListLog.GetListLogMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListLog.GetListLogMock.defaultExpectation.params
		mm_got := AuthRepositoryMockGetListLogParams{ctx, pageNumber, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListLog.t.Errorf("AuthRepositoryMock.GetListLog got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListLog.GetListLogMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListLog.t.Fatal("No results are set for the AuthRepositoryMock.GetListLog")
		}
		return (*mm_results).lpa1, (*mm_results).err
	}
	if mmGetListLog.funcGetListLog != nil {
		return mmGetListLog.funcGetListLog(ctx, pageNumber, pageSize)
	}
	mmGetListLog.t.Fatalf("Unexpected call to AuthRepositoryMock.GetListLog. %v %v %v", ctx, pageNumber, pageSize)
	return
}

// GetListLogAfterCounter returns a count of finished AuthRepositoryMock.GetListLog invocations
func (mmGetListLog *AuthRepositoryMock) GetListLogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListLog.afterGetListLogCounter)
}

// GetListLogBeforeCounter returns a count of AuthRepositoryMock.GetListLog invocations
func (mmGetListLog *AuthRepositoryMock) GetListLogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListLog.beforeGetListLogCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.GetListLog.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListLog *mAuthRepositoryMockGetListLog) Calls() []*AuthRepositoryMockGetListLogParams {
	mmGetListLog.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockGetListLogParams, len(mmGetListLog.callArgs))
	copy(argCopy, mmGetListLog.callArgs)

	mmGetListLog.mutex.RUnlock()

	return argCopy
}

// MinimockGetListLogDone returns true if the count of the GetListLog invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockGetListLogDone() bool {
	for _, e := range m.GetListLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListLog != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListLogInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockGetListLogInspect() {
	for _, e := range m.GetListLogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetListLog with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListLogMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		if m.GetListLogMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthRepositoryMock.GetListLog")
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.GetListLog with params: %#v", *m.GetListLogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListLog != nil && mm_atomic.LoadUint64(&m.afterGetListLogCounter) < 1 {
		m.t.Error("Expected call to AuthRepositoryMock.GetListLog")
	}
}

type mAuthRepositoryMockUpdate struct {
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockUpdateExpectation
	expectations       []*AuthRepositoryMockUpdateExpectation

	callArgs []*AuthRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// AuthRepositoryMockUpdateExpectation specifies expectation struct of the AuthRepository.Update
type AuthRepositoryMockUpdateExpectation struct {
	mock    *AuthRepositoryMock
	params  *AuthRepositoryMockUpdateParams
	results *AuthRepositoryMockUpdateResults
	Counter uint64
}

// AuthRepositoryMockUpdateParams contains parameters of the AuthRepository.Update
type AuthRepositoryMockUpdateParams struct {
	ctx        context.Context
	updateUser *model.UpdateUserRequest
}

// AuthRepositoryMockUpdateResults contains results of the AuthRepository.Update
type AuthRepositoryMockUpdateResults struct {
	q1  db.Query
	err error
}

// Expect sets up expected params for AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) Expect(ctx context.Context, updateUser *model.UpdateUserRequest) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &AuthRepositoryMockUpdateParams{ctx, updateUser}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) Inspect(f func(ctx context.Context, updateUser *model.UpdateUserRequest)) *mAuthRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by AuthRepository.Update
func (mmUpdate *mAuthRepositoryMockUpdate) Return(q1 db.Query, err error) *AuthRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &AuthRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &AuthRepositoryMockUpdateResults{q1, err}
	return mmUpdate.mock
}

// Set uses given function f to mock the AuthRepository.Update method
func (mmUpdate *mAuthRepositoryMockUpdate) Set(f func(ctx context.Context, updateUser *model.UpdateUserRequest) (q1 db.Query, err error)) *AuthRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the AuthRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the AuthRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the AuthRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mAuthRepositoryMockUpdate) When(ctx context.Context, updateUser *model.UpdateUserRequest) *AuthRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("AuthRepositoryMock.Update mock is already set by Set")
	}

	expectation := &AuthRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &AuthRepositoryMockUpdateParams{ctx, updateUser},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.Update return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockUpdateExpectation) Then(q1 db.Query, err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockUpdateResults{q1, err}
	return e.mock
}

// Update implements repository.AuthRepository
func (mmUpdate *AuthRepositoryMock) Update(ctx context.Context, updateUser *model.UpdateUserRequest) (q1 db.Query, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, updateUser)
	}

	mm_params := AuthRepositoryMockUpdateParams{ctx, updateUser}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.q1, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := AuthRepositoryMockUpdateParams{ctx, updateUser}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("AuthRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the AuthRepositoryMock.Update")
		}
		return (*mm_results).q1, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, updateUser)
	}
	mmUpdate.t.Fatalf("Unexpected call to AuthRepositoryMock.Update. %v %v", ctx, updateUser)
	return
}

// UpdateAfterCounter returns a count of finished AuthRepositoryMock.Update invocations
func (mmUpdate *AuthRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of AuthRepositoryMock.Update invocations
func (mmUpdate *AuthRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mAuthRepositoryMockUpdate) Calls() []*AuthRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to AuthRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockCreateLogInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetListLogInspect()

			m.MinimockUpdateInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateLogDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetListLogDone() &&
		m.MinimockUpdateDone()
}
