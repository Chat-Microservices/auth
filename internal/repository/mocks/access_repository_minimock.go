// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/semho/chat-microservices/auth/internal/repository.AccessRepository -o access_repository_minimock.go -n AccessRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/semho/chat-microservices/auth/internal/model"
)

// AccessRepositoryMock implements repository.AccessRepository
type AccessRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAccessibleRoles          func(ctx context.Context) (m1 map[string]int, err error)
	inspectFuncAccessibleRoles   func(ctx context.Context)
	afterAccessibleRolesCounter  uint64
	beforeAccessibleRolesCounter uint64
	AccessibleRolesMock          mAccessRepositoryMockAccessibleRoles

	funcCreateAccess          func(ctx context.Context, roleId int, path string) (i1 int64, err error)
	inspectFuncCreateAccess   func(ctx context.Context, roleId int, path string)
	afterCreateAccessCounter  uint64
	beforeCreateAccessCounter uint64
	CreateAccessMock          mAccessRepositoryMockCreateAccess

	funcDeleteAccess          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteAccess   func(ctx context.Context, id int64)
	afterDeleteAccessCounter  uint64
	beforeDeleteAccessCounter uint64
	DeleteAccessMock          mAccessRepositoryMockDeleteAccess

	funcGetListAccess          func(ctx context.Context, pageNumber uint64, pageSize uint64) (apa1 []*model.Access, err error)
	inspectFuncGetListAccess   func(ctx context.Context, pageNumber uint64, pageSize uint64)
	afterGetListAccessCounter  uint64
	beforeGetListAccessCounter uint64
	GetListAccessMock          mAccessRepositoryMockGetListAccess

	funcUpdateAccess          func(ctx context.Context, access *model.Access) (err error)
	inspectFuncUpdateAccess   func(ctx context.Context, access *model.Access)
	afterUpdateAccessCounter  uint64
	beforeUpdateAccessCounter uint64
	UpdateAccessMock          mAccessRepositoryMockUpdateAccess
}

// NewAccessRepositoryMock returns a mock for repository.AccessRepository
func NewAccessRepositoryMock(t minimock.Tester) *AccessRepositoryMock {
	m := &AccessRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccessibleRolesMock = mAccessRepositoryMockAccessibleRoles{mock: m}
	m.AccessibleRolesMock.callArgs = []*AccessRepositoryMockAccessibleRolesParams{}

	m.CreateAccessMock = mAccessRepositoryMockCreateAccess{mock: m}
	m.CreateAccessMock.callArgs = []*AccessRepositoryMockCreateAccessParams{}

	m.DeleteAccessMock = mAccessRepositoryMockDeleteAccess{mock: m}
	m.DeleteAccessMock.callArgs = []*AccessRepositoryMockDeleteAccessParams{}

	m.GetListAccessMock = mAccessRepositoryMockGetListAccess{mock: m}
	m.GetListAccessMock.callArgs = []*AccessRepositoryMockGetListAccessParams{}

	m.UpdateAccessMock = mAccessRepositoryMockUpdateAccess{mock: m}
	m.UpdateAccessMock.callArgs = []*AccessRepositoryMockUpdateAccessParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAccessRepositoryMockAccessibleRoles struct {
	mock               *AccessRepositoryMock
	defaultExpectation *AccessRepositoryMockAccessibleRolesExpectation
	expectations       []*AccessRepositoryMockAccessibleRolesExpectation

	callArgs []*AccessRepositoryMockAccessibleRolesParams
	mutex    sync.RWMutex
}

// AccessRepositoryMockAccessibleRolesExpectation specifies expectation struct of the AccessRepository.AccessibleRoles
type AccessRepositoryMockAccessibleRolesExpectation struct {
	mock    *AccessRepositoryMock
	params  *AccessRepositoryMockAccessibleRolesParams
	results *AccessRepositoryMockAccessibleRolesResults
	Counter uint64
}

// AccessRepositoryMockAccessibleRolesParams contains parameters of the AccessRepository.AccessibleRoles
type AccessRepositoryMockAccessibleRolesParams struct {
	ctx context.Context
}

// AccessRepositoryMockAccessibleRolesResults contains results of the AccessRepository.AccessibleRoles
type AccessRepositoryMockAccessibleRolesResults struct {
	m1  map[string]int
	err error
}

// Expect sets up expected params for AccessRepository.AccessibleRoles
func (mmAccessibleRoles *mAccessRepositoryMockAccessibleRoles) Expect(ctx context.Context) *mAccessRepositoryMockAccessibleRoles {
	if mmAccessibleRoles.mock.funcAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("AccessRepositoryMock.AccessibleRoles mock is already set by Set")
	}

	if mmAccessibleRoles.defaultExpectation == nil {
		mmAccessibleRoles.defaultExpectation = &AccessRepositoryMockAccessibleRolesExpectation{}
	}

	mmAccessibleRoles.defaultExpectation.params = &AccessRepositoryMockAccessibleRolesParams{ctx}
	for _, e := range mmAccessibleRoles.expectations {
		if minimock.Equal(e.params, mmAccessibleRoles.defaultExpectation.params) {
			mmAccessibleRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAccessibleRoles.defaultExpectation.params)
		}
	}

	return mmAccessibleRoles
}

// Inspect accepts an inspector function that has same arguments as the AccessRepository.AccessibleRoles
func (mmAccessibleRoles *mAccessRepositoryMockAccessibleRoles) Inspect(f func(ctx context.Context)) *mAccessRepositoryMockAccessibleRoles {
	if mmAccessibleRoles.mock.inspectFuncAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("Inspect function is already set for AccessRepositoryMock.AccessibleRoles")
	}

	mmAccessibleRoles.mock.inspectFuncAccessibleRoles = f

	return mmAccessibleRoles
}

// Return sets up results that will be returned by AccessRepository.AccessibleRoles
func (mmAccessibleRoles *mAccessRepositoryMockAccessibleRoles) Return(m1 map[string]int, err error) *AccessRepositoryMock {
	if mmAccessibleRoles.mock.funcAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("AccessRepositoryMock.AccessibleRoles mock is already set by Set")
	}

	if mmAccessibleRoles.defaultExpectation == nil {
		mmAccessibleRoles.defaultExpectation = &AccessRepositoryMockAccessibleRolesExpectation{mock: mmAccessibleRoles.mock}
	}
	mmAccessibleRoles.defaultExpectation.results = &AccessRepositoryMockAccessibleRolesResults{m1, err}
	return mmAccessibleRoles.mock
}

// Set uses given function f to mock the AccessRepository.AccessibleRoles method
func (mmAccessibleRoles *mAccessRepositoryMockAccessibleRoles) Set(f func(ctx context.Context) (m1 map[string]int, err error)) *AccessRepositoryMock {
	if mmAccessibleRoles.defaultExpectation != nil {
		mmAccessibleRoles.mock.t.Fatalf("Default expectation is already set for the AccessRepository.AccessibleRoles method")
	}

	if len(mmAccessibleRoles.expectations) > 0 {
		mmAccessibleRoles.mock.t.Fatalf("Some expectations are already set for the AccessRepository.AccessibleRoles method")
	}

	mmAccessibleRoles.mock.funcAccessibleRoles = f
	return mmAccessibleRoles.mock
}

// When sets expectation for the AccessRepository.AccessibleRoles which will trigger the result defined by the following
// Then helper
func (mmAccessibleRoles *mAccessRepositoryMockAccessibleRoles) When(ctx context.Context) *AccessRepositoryMockAccessibleRolesExpectation {
	if mmAccessibleRoles.mock.funcAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("AccessRepositoryMock.AccessibleRoles mock is already set by Set")
	}

	expectation := &AccessRepositoryMockAccessibleRolesExpectation{
		mock:   mmAccessibleRoles.mock,
		params: &AccessRepositoryMockAccessibleRolesParams{ctx},
	}
	mmAccessibleRoles.expectations = append(mmAccessibleRoles.expectations, expectation)
	return expectation
}

// Then sets up AccessRepository.AccessibleRoles return parameters for the expectation previously defined by the When method
func (e *AccessRepositoryMockAccessibleRolesExpectation) Then(m1 map[string]int, err error) *AccessRepositoryMock {
	e.results = &AccessRepositoryMockAccessibleRolesResults{m1, err}
	return e.mock
}

// AccessibleRoles implements repository.AccessRepository
func (mmAccessibleRoles *AccessRepositoryMock) AccessibleRoles(ctx context.Context) (m1 map[string]int, err error) {
	mm_atomic.AddUint64(&mmAccessibleRoles.beforeAccessibleRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessibleRoles.afterAccessibleRolesCounter, 1)

	if mmAccessibleRoles.inspectFuncAccessibleRoles != nil {
		mmAccessibleRoles.inspectFuncAccessibleRoles(ctx)
	}

	mm_params := AccessRepositoryMockAccessibleRolesParams{ctx}

	// Record call args
	mmAccessibleRoles.AccessibleRolesMock.mutex.Lock()
	mmAccessibleRoles.AccessibleRolesMock.callArgs = append(mmAccessibleRoles.AccessibleRolesMock.callArgs, &mm_params)
	mmAccessibleRoles.AccessibleRolesMock.mutex.Unlock()

	for _, e := range mmAccessibleRoles.AccessibleRolesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmAccessibleRoles.AccessibleRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessibleRoles.AccessibleRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmAccessibleRoles.AccessibleRolesMock.defaultExpectation.params
		mm_got := AccessRepositoryMockAccessibleRolesParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAccessibleRoles.t.Errorf("AccessRepositoryMock.AccessibleRoles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAccessibleRoles.AccessibleRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessibleRoles.t.Fatal("No results are set for the AccessRepositoryMock.AccessibleRoles")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmAccessibleRoles.funcAccessibleRoles != nil {
		return mmAccessibleRoles.funcAccessibleRoles(ctx)
	}
	mmAccessibleRoles.t.Fatalf("Unexpected call to AccessRepositoryMock.AccessibleRoles. %v", ctx)
	return
}

// AccessibleRolesAfterCounter returns a count of finished AccessRepositoryMock.AccessibleRoles invocations
func (mmAccessibleRoles *AccessRepositoryMock) AccessibleRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessibleRoles.afterAccessibleRolesCounter)
}

// AccessibleRolesBeforeCounter returns a count of AccessRepositoryMock.AccessibleRoles invocations
func (mmAccessibleRoles *AccessRepositoryMock) AccessibleRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessibleRoles.beforeAccessibleRolesCounter)
}

// Calls returns a list of arguments used in each call to AccessRepositoryMock.AccessibleRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAccessibleRoles *mAccessRepositoryMockAccessibleRoles) Calls() []*AccessRepositoryMockAccessibleRolesParams {
	mmAccessibleRoles.mutex.RLock()

	argCopy := make([]*AccessRepositoryMockAccessibleRolesParams, len(mmAccessibleRoles.callArgs))
	copy(argCopy, mmAccessibleRoles.callArgs)

	mmAccessibleRoles.mutex.RUnlock()

	return argCopy
}

// MinimockAccessibleRolesDone returns true if the count of the AccessibleRoles invocations corresponds
// the number of defined expectations
func (m *AccessRepositoryMock) MinimockAccessibleRolesDone() bool {
	for _, e := range m.AccessibleRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccessibleRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessibleRoles != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAccessibleRolesInspect logs each unmet expectation
func (m *AccessRepositoryMock) MinimockAccessibleRolesInspect() {
	for _, e := range m.AccessibleRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessRepositoryMock.AccessibleRoles with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccessibleRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		if m.AccessibleRolesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessRepositoryMock.AccessibleRoles")
		} else {
			m.t.Errorf("Expected call to AccessRepositoryMock.AccessibleRoles with params: %#v", *m.AccessibleRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessibleRoles != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		m.t.Error("Expected call to AccessRepositoryMock.AccessibleRoles")
	}
}

type mAccessRepositoryMockCreateAccess struct {
	mock               *AccessRepositoryMock
	defaultExpectation *AccessRepositoryMockCreateAccessExpectation
	expectations       []*AccessRepositoryMockCreateAccessExpectation

	callArgs []*AccessRepositoryMockCreateAccessParams
	mutex    sync.RWMutex
}

// AccessRepositoryMockCreateAccessExpectation specifies expectation struct of the AccessRepository.CreateAccess
type AccessRepositoryMockCreateAccessExpectation struct {
	mock    *AccessRepositoryMock
	params  *AccessRepositoryMockCreateAccessParams
	results *AccessRepositoryMockCreateAccessResults
	Counter uint64
}

// AccessRepositoryMockCreateAccessParams contains parameters of the AccessRepository.CreateAccess
type AccessRepositoryMockCreateAccessParams struct {
	ctx    context.Context
	roleId int
	path   string
}

// AccessRepositoryMockCreateAccessResults contains results of the AccessRepository.CreateAccess
type AccessRepositoryMockCreateAccessResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for AccessRepository.CreateAccess
func (mmCreateAccess *mAccessRepositoryMockCreateAccess) Expect(ctx context.Context, roleId int, path string) *mAccessRepositoryMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("AccessRepositoryMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &AccessRepositoryMockCreateAccessExpectation{}
	}

	mmCreateAccess.defaultExpectation.params = &AccessRepositoryMockCreateAccessParams{ctx, roleId, path}
	for _, e := range mmCreateAccess.expectations {
		if minimock.Equal(e.params, mmCreateAccess.defaultExpectation.params) {
			mmCreateAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccess.defaultExpectation.params)
		}
	}

	return mmCreateAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessRepository.CreateAccess
func (mmCreateAccess *mAccessRepositoryMockCreateAccess) Inspect(f func(ctx context.Context, roleId int, path string)) *mAccessRepositoryMockCreateAccess {
	if mmCreateAccess.mock.inspectFuncCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("Inspect function is already set for AccessRepositoryMock.CreateAccess")
	}

	mmCreateAccess.mock.inspectFuncCreateAccess = f

	return mmCreateAccess
}

// Return sets up results that will be returned by AccessRepository.CreateAccess
func (mmCreateAccess *mAccessRepositoryMockCreateAccess) Return(i1 int64, err error) *AccessRepositoryMock {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("AccessRepositoryMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &AccessRepositoryMockCreateAccessExpectation{mock: mmCreateAccess.mock}
	}
	mmCreateAccess.defaultExpectation.results = &AccessRepositoryMockCreateAccessResults{i1, err}
	return mmCreateAccess.mock
}

// Set uses given function f to mock the AccessRepository.CreateAccess method
func (mmCreateAccess *mAccessRepositoryMockCreateAccess) Set(f func(ctx context.Context, roleId int, path string) (i1 int64, err error)) *AccessRepositoryMock {
	if mmCreateAccess.defaultExpectation != nil {
		mmCreateAccess.mock.t.Fatalf("Default expectation is already set for the AccessRepository.CreateAccess method")
	}

	if len(mmCreateAccess.expectations) > 0 {
		mmCreateAccess.mock.t.Fatalf("Some expectations are already set for the AccessRepository.CreateAccess method")
	}

	mmCreateAccess.mock.funcCreateAccess = f
	return mmCreateAccess.mock
}

// When sets expectation for the AccessRepository.CreateAccess which will trigger the result defined by the following
// Then helper
func (mmCreateAccess *mAccessRepositoryMockCreateAccess) When(ctx context.Context, roleId int, path string) *AccessRepositoryMockCreateAccessExpectation {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("AccessRepositoryMock.CreateAccess mock is already set by Set")
	}

	expectation := &AccessRepositoryMockCreateAccessExpectation{
		mock:   mmCreateAccess.mock,
		params: &AccessRepositoryMockCreateAccessParams{ctx, roleId, path},
	}
	mmCreateAccess.expectations = append(mmCreateAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessRepository.CreateAccess return parameters for the expectation previously defined by the When method
func (e *AccessRepositoryMockCreateAccessExpectation) Then(i1 int64, err error) *AccessRepositoryMock {
	e.results = &AccessRepositoryMockCreateAccessResults{i1, err}
	return e.mock
}

// CreateAccess implements repository.AccessRepository
func (mmCreateAccess *AccessRepositoryMock) CreateAccess(ctx context.Context, roleId int, path string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateAccess.beforeCreateAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccess.afterCreateAccessCounter, 1)

	if mmCreateAccess.inspectFuncCreateAccess != nil {
		mmCreateAccess.inspectFuncCreateAccess(ctx, roleId, path)
	}

	mm_params := AccessRepositoryMockCreateAccessParams{ctx, roleId, path}

	// Record call args
	mmCreateAccess.CreateAccessMock.mutex.Lock()
	mmCreateAccess.CreateAccessMock.callArgs = append(mmCreateAccess.CreateAccessMock.callArgs, &mm_params)
	mmCreateAccess.CreateAccessMock.mutex.Unlock()

	for _, e := range mmCreateAccess.CreateAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateAccess.CreateAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccess.CreateAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccess.CreateAccessMock.defaultExpectation.params
		mm_got := AccessRepositoryMockCreateAccessParams{ctx, roleId, path}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccess.t.Errorf("AccessRepositoryMock.CreateAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccess.CreateAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccess.t.Fatal("No results are set for the AccessRepositoryMock.CreateAccess")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateAccess.funcCreateAccess != nil {
		return mmCreateAccess.funcCreateAccess(ctx, roleId, path)
	}
	mmCreateAccess.t.Fatalf("Unexpected call to AccessRepositoryMock.CreateAccess. %v %v %v", ctx, roleId, path)
	return
}

// CreateAccessAfterCounter returns a count of finished AccessRepositoryMock.CreateAccess invocations
func (mmCreateAccess *AccessRepositoryMock) CreateAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.afterCreateAccessCounter)
}

// CreateAccessBeforeCounter returns a count of AccessRepositoryMock.CreateAccess invocations
func (mmCreateAccess *AccessRepositoryMock) CreateAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.beforeCreateAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessRepositoryMock.CreateAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccess *mAccessRepositoryMockCreateAccess) Calls() []*AccessRepositoryMockCreateAccessParams {
	mmCreateAccess.mutex.RLock()

	argCopy := make([]*AccessRepositoryMockCreateAccessParams, len(mmCreateAccess.callArgs))
	copy(argCopy, mmCreateAccess.callArgs)

	mmCreateAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessDone returns true if the count of the CreateAccess invocations corresponds
// the number of defined expectations
func (m *AccessRepositoryMock) MinimockCreateAccessDone() bool {
	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccess != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateAccessInspect logs each unmet expectation
func (m *AccessRepositoryMock) MinimockCreateAccessInspect() {
	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessRepositoryMock.CreateAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		if m.CreateAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessRepositoryMock.CreateAccess")
		} else {
			m.t.Errorf("Expected call to AccessRepositoryMock.CreateAccess with params: %#v", *m.CreateAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccess != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		m.t.Error("Expected call to AccessRepositoryMock.CreateAccess")
	}
}

type mAccessRepositoryMockDeleteAccess struct {
	mock               *AccessRepositoryMock
	defaultExpectation *AccessRepositoryMockDeleteAccessExpectation
	expectations       []*AccessRepositoryMockDeleteAccessExpectation

	callArgs []*AccessRepositoryMockDeleteAccessParams
	mutex    sync.RWMutex
}

// AccessRepositoryMockDeleteAccessExpectation specifies expectation struct of the AccessRepository.DeleteAccess
type AccessRepositoryMockDeleteAccessExpectation struct {
	mock    *AccessRepositoryMock
	params  *AccessRepositoryMockDeleteAccessParams
	results *AccessRepositoryMockDeleteAccessResults
	Counter uint64
}

// AccessRepositoryMockDeleteAccessParams contains parameters of the AccessRepository.DeleteAccess
type AccessRepositoryMockDeleteAccessParams struct {
	ctx context.Context
	id  int64
}

// AccessRepositoryMockDeleteAccessResults contains results of the AccessRepository.DeleteAccess
type AccessRepositoryMockDeleteAccessResults struct {
	err error
}

// Expect sets up expected params for AccessRepository.DeleteAccess
func (mmDeleteAccess *mAccessRepositoryMockDeleteAccess) Expect(ctx context.Context, id int64) *mAccessRepositoryMockDeleteAccess {
	if mmDeleteAccess.mock.funcDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("AccessRepositoryMock.DeleteAccess mock is already set by Set")
	}

	if mmDeleteAccess.defaultExpectation == nil {
		mmDeleteAccess.defaultExpectation = &AccessRepositoryMockDeleteAccessExpectation{}
	}

	mmDeleteAccess.defaultExpectation.params = &AccessRepositoryMockDeleteAccessParams{ctx, id}
	for _, e := range mmDeleteAccess.expectations {
		if minimock.Equal(e.params, mmDeleteAccess.defaultExpectation.params) {
			mmDeleteAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAccess.defaultExpectation.params)
		}
	}

	return mmDeleteAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessRepository.DeleteAccess
func (mmDeleteAccess *mAccessRepositoryMockDeleteAccess) Inspect(f func(ctx context.Context, id int64)) *mAccessRepositoryMockDeleteAccess {
	if mmDeleteAccess.mock.inspectFuncDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("Inspect function is already set for AccessRepositoryMock.DeleteAccess")
	}

	mmDeleteAccess.mock.inspectFuncDeleteAccess = f

	return mmDeleteAccess
}

// Return sets up results that will be returned by AccessRepository.DeleteAccess
func (mmDeleteAccess *mAccessRepositoryMockDeleteAccess) Return(err error) *AccessRepositoryMock {
	if mmDeleteAccess.mock.funcDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("AccessRepositoryMock.DeleteAccess mock is already set by Set")
	}

	if mmDeleteAccess.defaultExpectation == nil {
		mmDeleteAccess.defaultExpectation = &AccessRepositoryMockDeleteAccessExpectation{mock: mmDeleteAccess.mock}
	}
	mmDeleteAccess.defaultExpectation.results = &AccessRepositoryMockDeleteAccessResults{err}
	return mmDeleteAccess.mock
}

// Set uses given function f to mock the AccessRepository.DeleteAccess method
func (mmDeleteAccess *mAccessRepositoryMockDeleteAccess) Set(f func(ctx context.Context, id int64) (err error)) *AccessRepositoryMock {
	if mmDeleteAccess.defaultExpectation != nil {
		mmDeleteAccess.mock.t.Fatalf("Default expectation is already set for the AccessRepository.DeleteAccess method")
	}

	if len(mmDeleteAccess.expectations) > 0 {
		mmDeleteAccess.mock.t.Fatalf("Some expectations are already set for the AccessRepository.DeleteAccess method")
	}

	mmDeleteAccess.mock.funcDeleteAccess = f
	return mmDeleteAccess.mock
}

// When sets expectation for the AccessRepository.DeleteAccess which will trigger the result defined by the following
// Then helper
func (mmDeleteAccess *mAccessRepositoryMockDeleteAccess) When(ctx context.Context, id int64) *AccessRepositoryMockDeleteAccessExpectation {
	if mmDeleteAccess.mock.funcDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("AccessRepositoryMock.DeleteAccess mock is already set by Set")
	}

	expectation := &AccessRepositoryMockDeleteAccessExpectation{
		mock:   mmDeleteAccess.mock,
		params: &AccessRepositoryMockDeleteAccessParams{ctx, id},
	}
	mmDeleteAccess.expectations = append(mmDeleteAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessRepository.DeleteAccess return parameters for the expectation previously defined by the When method
func (e *AccessRepositoryMockDeleteAccessExpectation) Then(err error) *AccessRepositoryMock {
	e.results = &AccessRepositoryMockDeleteAccessResults{err}
	return e.mock
}

// DeleteAccess implements repository.AccessRepository
func (mmDeleteAccess *AccessRepositoryMock) DeleteAccess(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteAccess.beforeDeleteAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAccess.afterDeleteAccessCounter, 1)

	if mmDeleteAccess.inspectFuncDeleteAccess != nil {
		mmDeleteAccess.inspectFuncDeleteAccess(ctx, id)
	}

	mm_params := AccessRepositoryMockDeleteAccessParams{ctx, id}

	// Record call args
	mmDeleteAccess.DeleteAccessMock.mutex.Lock()
	mmDeleteAccess.DeleteAccessMock.callArgs = append(mmDeleteAccess.DeleteAccessMock.callArgs, &mm_params)
	mmDeleteAccess.DeleteAccessMock.mutex.Unlock()

	for _, e := range mmDeleteAccess.DeleteAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAccess.DeleteAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAccess.DeleteAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAccess.DeleteAccessMock.defaultExpectation.params
		mm_got := AccessRepositoryMockDeleteAccessParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAccess.t.Errorf("AccessRepositoryMock.DeleteAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAccess.DeleteAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAccess.t.Fatal("No results are set for the AccessRepositoryMock.DeleteAccess")
		}
		return (*mm_results).err
	}
	if mmDeleteAccess.funcDeleteAccess != nil {
		return mmDeleteAccess.funcDeleteAccess(ctx, id)
	}
	mmDeleteAccess.t.Fatalf("Unexpected call to AccessRepositoryMock.DeleteAccess. %v %v", ctx, id)
	return
}

// DeleteAccessAfterCounter returns a count of finished AccessRepositoryMock.DeleteAccess invocations
func (mmDeleteAccess *AccessRepositoryMock) DeleteAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAccess.afterDeleteAccessCounter)
}

// DeleteAccessBeforeCounter returns a count of AccessRepositoryMock.DeleteAccess invocations
func (mmDeleteAccess *AccessRepositoryMock) DeleteAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAccess.beforeDeleteAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessRepositoryMock.DeleteAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAccess *mAccessRepositoryMockDeleteAccess) Calls() []*AccessRepositoryMockDeleteAccessParams {
	mmDeleteAccess.mutex.RLock()

	argCopy := make([]*AccessRepositoryMockDeleteAccessParams, len(mmDeleteAccess.callArgs))
	copy(argCopy, mmDeleteAccess.callArgs)

	mmDeleteAccess.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAccessDone returns true if the count of the DeleteAccess invocations corresponds
// the number of defined expectations
func (m *AccessRepositoryMock) MinimockDeleteAccessDone() bool {
	for _, e := range m.DeleteAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAccess != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteAccessInspect logs each unmet expectation
func (m *AccessRepositoryMock) MinimockDeleteAccessInspect() {
	for _, e := range m.DeleteAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessRepositoryMock.DeleteAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		if m.DeleteAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessRepositoryMock.DeleteAccess")
		} else {
			m.t.Errorf("Expected call to AccessRepositoryMock.DeleteAccess with params: %#v", *m.DeleteAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAccess != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		m.t.Error("Expected call to AccessRepositoryMock.DeleteAccess")
	}
}

type mAccessRepositoryMockGetListAccess struct {
	mock               *AccessRepositoryMock
	defaultExpectation *AccessRepositoryMockGetListAccessExpectation
	expectations       []*AccessRepositoryMockGetListAccessExpectation

	callArgs []*AccessRepositoryMockGetListAccessParams
	mutex    sync.RWMutex
}

// AccessRepositoryMockGetListAccessExpectation specifies expectation struct of the AccessRepository.GetListAccess
type AccessRepositoryMockGetListAccessExpectation struct {
	mock    *AccessRepositoryMock
	params  *AccessRepositoryMockGetListAccessParams
	results *AccessRepositoryMockGetListAccessResults
	Counter uint64
}

// AccessRepositoryMockGetListAccessParams contains parameters of the AccessRepository.GetListAccess
type AccessRepositoryMockGetListAccessParams struct {
	ctx        context.Context
	pageNumber uint64
	pageSize   uint64
}

// AccessRepositoryMockGetListAccessResults contains results of the AccessRepository.GetListAccess
type AccessRepositoryMockGetListAccessResults struct {
	apa1 []*model.Access
	err  error
}

// Expect sets up expected params for AccessRepository.GetListAccess
func (mmGetListAccess *mAccessRepositoryMockGetListAccess) Expect(ctx context.Context, pageNumber uint64, pageSize uint64) *mAccessRepositoryMockGetListAccess {
	if mmGetListAccess.mock.funcGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("AccessRepositoryMock.GetListAccess mock is already set by Set")
	}

	if mmGetListAccess.defaultExpectation == nil {
		mmGetListAccess.defaultExpectation = &AccessRepositoryMockGetListAccessExpectation{}
	}

	mmGetListAccess.defaultExpectation.params = &AccessRepositoryMockGetListAccessParams{ctx, pageNumber, pageSize}
	for _, e := range mmGetListAccess.expectations {
		if minimock.Equal(e.params, mmGetListAccess.defaultExpectation.params) {
			mmGetListAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListAccess.defaultExpectation.params)
		}
	}

	return mmGetListAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessRepository.GetListAccess
func (mmGetListAccess *mAccessRepositoryMockGetListAccess) Inspect(f func(ctx context.Context, pageNumber uint64, pageSize uint64)) *mAccessRepositoryMockGetListAccess {
	if mmGetListAccess.mock.inspectFuncGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("Inspect function is already set for AccessRepositoryMock.GetListAccess")
	}

	mmGetListAccess.mock.inspectFuncGetListAccess = f

	return mmGetListAccess
}

// Return sets up results that will be returned by AccessRepository.GetListAccess
func (mmGetListAccess *mAccessRepositoryMockGetListAccess) Return(apa1 []*model.Access, err error) *AccessRepositoryMock {
	if mmGetListAccess.mock.funcGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("AccessRepositoryMock.GetListAccess mock is already set by Set")
	}

	if mmGetListAccess.defaultExpectation == nil {
		mmGetListAccess.defaultExpectation = &AccessRepositoryMockGetListAccessExpectation{mock: mmGetListAccess.mock}
	}
	mmGetListAccess.defaultExpectation.results = &AccessRepositoryMockGetListAccessResults{apa1, err}
	return mmGetListAccess.mock
}

// Set uses given function f to mock the AccessRepository.GetListAccess method
func (mmGetListAccess *mAccessRepositoryMockGetListAccess) Set(f func(ctx context.Context, pageNumber uint64, pageSize uint64) (apa1 []*model.Access, err error)) *AccessRepositoryMock {
	if mmGetListAccess.defaultExpectation != nil {
		mmGetListAccess.mock.t.Fatalf("Default expectation is already set for the AccessRepository.GetListAccess method")
	}

	if len(mmGetListAccess.expectations) > 0 {
		mmGetListAccess.mock.t.Fatalf("Some expectations are already set for the AccessRepository.GetListAccess method")
	}

	mmGetListAccess.mock.funcGetListAccess = f
	return mmGetListAccess.mock
}

// When sets expectation for the AccessRepository.GetListAccess which will trigger the result defined by the following
// Then helper
func (mmGetListAccess *mAccessRepositoryMockGetListAccess) When(ctx context.Context, pageNumber uint64, pageSize uint64) *AccessRepositoryMockGetListAccessExpectation {
	if mmGetListAccess.mock.funcGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("AccessRepositoryMock.GetListAccess mock is already set by Set")
	}

	expectation := &AccessRepositoryMockGetListAccessExpectation{
		mock:   mmGetListAccess.mock,
		params: &AccessRepositoryMockGetListAccessParams{ctx, pageNumber, pageSize},
	}
	mmGetListAccess.expectations = append(mmGetListAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessRepository.GetListAccess return parameters for the expectation previously defined by the When method
func (e *AccessRepositoryMockGetListAccessExpectation) Then(apa1 []*model.Access, err error) *AccessRepositoryMock {
	e.results = &AccessRepositoryMockGetListAccessResults{apa1, err}
	return e.mock
}

// GetListAccess implements repository.AccessRepository
func (mmGetListAccess *AccessRepositoryMock) GetListAccess(ctx context.Context, pageNumber uint64, pageSize uint64) (apa1 []*model.Access, err error) {
	mm_atomic.AddUint64(&mmGetListAccess.beforeGetListAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListAccess.afterGetListAccessCounter, 1)

	if mmGetListAccess.inspectFuncGetListAccess != nil {
		mmGetListAccess.inspectFuncGetListAccess(ctx, pageNumber, pageSize)
	}

	mm_params := AccessRepositoryMockGetListAccessParams{ctx, pageNumber, pageSize}

	// Record call args
	mmGetListAccess.GetListAccessMock.mutex.Lock()
	mmGetListAccess.GetListAccessMock.callArgs = append(mmGetListAccess.GetListAccessMock.callArgs, &mm_params)
	mmGetListAccess.GetListAccessMock.mutex.Unlock()

	for _, e := range mmGetListAccess.GetListAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmGetListAccess.GetListAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListAccess.GetListAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListAccess.GetListAccessMock.defaultExpectation.params
		mm_got := AccessRepositoryMockGetListAccessParams{ctx, pageNumber, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListAccess.t.Errorf("AccessRepositoryMock.GetListAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListAccess.GetListAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListAccess.t.Fatal("No results are set for the AccessRepositoryMock.GetListAccess")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmGetListAccess.funcGetListAccess != nil {
		return mmGetListAccess.funcGetListAccess(ctx, pageNumber, pageSize)
	}
	mmGetListAccess.t.Fatalf("Unexpected call to AccessRepositoryMock.GetListAccess. %v %v %v", ctx, pageNumber, pageSize)
	return
}

// GetListAccessAfterCounter returns a count of finished AccessRepositoryMock.GetListAccess invocations
func (mmGetListAccess *AccessRepositoryMock) GetListAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListAccess.afterGetListAccessCounter)
}

// GetListAccessBeforeCounter returns a count of AccessRepositoryMock.GetListAccess invocations
func (mmGetListAccess *AccessRepositoryMock) GetListAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListAccess.beforeGetListAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessRepositoryMock.GetListAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListAccess *mAccessRepositoryMockGetListAccess) Calls() []*AccessRepositoryMockGetListAccessParams {
	mmGetListAccess.mutex.RLock()

	argCopy := make([]*AccessRepositoryMockGetListAccessParams, len(mmGetListAccess.callArgs))
	copy(argCopy, mmGetListAccess.callArgs)

	mmGetListAccess.mutex.RUnlock()

	return argCopy
}

// MinimockGetListAccessDone returns true if the count of the GetListAccess invocations corresponds
// the number of defined expectations
func (m *AccessRepositoryMock) MinimockGetListAccessDone() bool {
	for _, e := range m.GetListAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListAccess != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListAccessInspect logs each unmet expectation
func (m *AccessRepositoryMock) MinimockGetListAccessInspect() {
	for _, e := range m.GetListAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessRepositoryMock.GetListAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		if m.GetListAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessRepositoryMock.GetListAccess")
		} else {
			m.t.Errorf("Expected call to AccessRepositoryMock.GetListAccess with params: %#v", *m.GetListAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListAccess != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		m.t.Error("Expected call to AccessRepositoryMock.GetListAccess")
	}
}

type mAccessRepositoryMockUpdateAccess struct {
	mock               *AccessRepositoryMock
	defaultExpectation *AccessRepositoryMockUpdateAccessExpectation
	expectations       []*AccessRepositoryMockUpdateAccessExpectation

	callArgs []*AccessRepositoryMockUpdateAccessParams
	mutex    sync.RWMutex
}

// AccessRepositoryMockUpdateAccessExpectation specifies expectation struct of the AccessRepository.UpdateAccess
type AccessRepositoryMockUpdateAccessExpectation struct {
	mock    *AccessRepositoryMock
	params  *AccessRepositoryMockUpdateAccessParams
	results *AccessRepositoryMockUpdateAccessResults
	Counter uint64
}

// AccessRepositoryMockUpdateAccessParams contains parameters of the AccessRepository.UpdateAccess
type AccessRepositoryMockUpdateAccessParams struct {
	ctx    context.Context
	access *model.Access
}

// AccessRepositoryMockUpdateAccessResults contains results of the AccessRepository.UpdateAccess
type AccessRepositoryMockUpdateAccessResults struct {
	err error
}

// Expect sets up expected params for AccessRepository.UpdateAccess
func (mmUpdateAccess *mAccessRepositoryMockUpdateAccess) Expect(ctx context.Context, access *model.Access) *mAccessRepositoryMockUpdateAccess {
	if mmUpdateAccess.mock.funcUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("AccessRepositoryMock.UpdateAccess mock is already set by Set")
	}

	if mmUpdateAccess.defaultExpectation == nil {
		mmUpdateAccess.defaultExpectation = &AccessRepositoryMockUpdateAccessExpectation{}
	}

	mmUpdateAccess.defaultExpectation.params = &AccessRepositoryMockUpdateAccessParams{ctx, access}
	for _, e := range mmUpdateAccess.expectations {
		if minimock.Equal(e.params, mmUpdateAccess.defaultExpectation.params) {
			mmUpdateAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAccess.defaultExpectation.params)
		}
	}

	return mmUpdateAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessRepository.UpdateAccess
func (mmUpdateAccess *mAccessRepositoryMockUpdateAccess) Inspect(f func(ctx context.Context, access *model.Access)) *mAccessRepositoryMockUpdateAccess {
	if mmUpdateAccess.mock.inspectFuncUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("Inspect function is already set for AccessRepositoryMock.UpdateAccess")
	}

	mmUpdateAccess.mock.inspectFuncUpdateAccess = f

	return mmUpdateAccess
}

// Return sets up results that will be returned by AccessRepository.UpdateAccess
func (mmUpdateAccess *mAccessRepositoryMockUpdateAccess) Return(err error) *AccessRepositoryMock {
	if mmUpdateAccess.mock.funcUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("AccessRepositoryMock.UpdateAccess mock is already set by Set")
	}

	if mmUpdateAccess.defaultExpectation == nil {
		mmUpdateAccess.defaultExpectation = &AccessRepositoryMockUpdateAccessExpectation{mock: mmUpdateAccess.mock}
	}
	mmUpdateAccess.defaultExpectation.results = &AccessRepositoryMockUpdateAccessResults{err}
	return mmUpdateAccess.mock
}

// Set uses given function f to mock the AccessRepository.UpdateAccess method
func (mmUpdateAccess *mAccessRepositoryMockUpdateAccess) Set(f func(ctx context.Context, access *model.Access) (err error)) *AccessRepositoryMock {
	if mmUpdateAccess.defaultExpectation != nil {
		mmUpdateAccess.mock.t.Fatalf("Default expectation is already set for the AccessRepository.UpdateAccess method")
	}

	if len(mmUpdateAccess.expectations) > 0 {
		mmUpdateAccess.mock.t.Fatalf("Some expectations are already set for the AccessRepository.UpdateAccess method")
	}

	mmUpdateAccess.mock.funcUpdateAccess = f
	return mmUpdateAccess.mock
}

// When sets expectation for the AccessRepository.UpdateAccess which will trigger the result defined by the following
// Then helper
func (mmUpdateAccess *mAccessRepositoryMockUpdateAccess) When(ctx context.Context, access *model.Access) *AccessRepositoryMockUpdateAccessExpectation {
	if mmUpdateAccess.mock.funcUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("AccessRepositoryMock.UpdateAccess mock is already set by Set")
	}

	expectation := &AccessRepositoryMockUpdateAccessExpectation{
		mock:   mmUpdateAccess.mock,
		params: &AccessRepositoryMockUpdateAccessParams{ctx, access},
	}
	mmUpdateAccess.expectations = append(mmUpdateAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessRepository.UpdateAccess return parameters for the expectation previously defined by the When method
func (e *AccessRepositoryMockUpdateAccessExpectation) Then(err error) *AccessRepositoryMock {
	e.results = &AccessRepositoryMockUpdateAccessResults{err}
	return e.mock
}

// UpdateAccess implements repository.AccessRepository
func (mmUpdateAccess *AccessRepositoryMock) UpdateAccess(ctx context.Context, access *model.Access) (err error) {
	mm_atomic.AddUint64(&mmUpdateAccess.beforeUpdateAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAccess.afterUpdateAccessCounter, 1)

	if mmUpdateAccess.inspectFuncUpdateAccess != nil {
		mmUpdateAccess.inspectFuncUpdateAccess(ctx, access)
	}

	mm_params := AccessRepositoryMockUpdateAccessParams{ctx, access}

	// Record call args
	mmUpdateAccess.UpdateAccessMock.mutex.Lock()
	mmUpdateAccess.UpdateAccessMock.callArgs = append(mmUpdateAccess.UpdateAccessMock.callArgs, &mm_params)
	mmUpdateAccess.UpdateAccessMock.mutex.Unlock()

	for _, e := range mmUpdateAccess.UpdateAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateAccess.UpdateAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAccess.UpdateAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAccess.UpdateAccessMock.defaultExpectation.params
		mm_got := AccessRepositoryMockUpdateAccessParams{ctx, access}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAccess.t.Errorf("AccessRepositoryMock.UpdateAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAccess.UpdateAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAccess.t.Fatal("No results are set for the AccessRepositoryMock.UpdateAccess")
		}
		return (*mm_results).err
	}
	if mmUpdateAccess.funcUpdateAccess != nil {
		return mmUpdateAccess.funcUpdateAccess(ctx, access)
	}
	mmUpdateAccess.t.Fatalf("Unexpected call to AccessRepositoryMock.UpdateAccess. %v %v", ctx, access)
	return
}

// UpdateAccessAfterCounter returns a count of finished AccessRepositoryMock.UpdateAccess invocations
func (mmUpdateAccess *AccessRepositoryMock) UpdateAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccess.afterUpdateAccessCounter)
}

// UpdateAccessBeforeCounter returns a count of AccessRepositoryMock.UpdateAccess invocations
func (mmUpdateAccess *AccessRepositoryMock) UpdateAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccess.beforeUpdateAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessRepositoryMock.UpdateAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAccess *mAccessRepositoryMockUpdateAccess) Calls() []*AccessRepositoryMockUpdateAccessParams {
	mmUpdateAccess.mutex.RLock()

	argCopy := make([]*AccessRepositoryMockUpdateAccessParams, len(mmUpdateAccess.callArgs))
	copy(argCopy, mmUpdateAccess.callArgs)

	mmUpdateAccess.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAccessDone returns true if the count of the UpdateAccess invocations corresponds
// the number of defined expectations
func (m *AccessRepositoryMock) MinimockUpdateAccessDone() bool {
	for _, e := range m.UpdateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccess != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAccessInspect logs each unmet expectation
func (m *AccessRepositoryMock) MinimockUpdateAccessInspect() {
	for _, e := range m.UpdateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessRepositoryMock.UpdateAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		if m.UpdateAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessRepositoryMock.UpdateAccess")
		} else {
			m.t.Errorf("Expected call to AccessRepositoryMock.UpdateAccess with params: %#v", *m.UpdateAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccess != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		m.t.Error("Expected call to AccessRepositoryMock.UpdateAccess")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccessRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAccessibleRolesInspect()

			m.MinimockCreateAccessInspect()

			m.MinimockDeleteAccessInspect()

			m.MinimockGetListAccessInspect()

			m.MinimockUpdateAccessInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccessRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccessRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccessibleRolesDone() &&
		m.MinimockCreateAccessDone() &&
		m.MinimockDeleteAccessDone() &&
		m.MinimockGetListAccessDone() &&
		m.MinimockUpdateAccessDone()
}
