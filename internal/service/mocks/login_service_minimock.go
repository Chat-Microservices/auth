// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/semho/chat-microservices/auth/internal/service.LoginService -o login_service_minimock.go -n LoginServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LoginServiceMock implements service.LoginService
type LoginServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetAccessToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	inspectFuncGetAccessToken   func(ctx context.Context, refreshToken string)
	afterGetAccessTokenCounter  uint64
	beforeGetAccessTokenCounter uint64
	GetAccessTokenMock          mLoginServiceMockGetAccessToken

	funcGetRefreshToken          func(ctx context.Context, refreshToken string) (s1 string, err error)
	inspectFuncGetRefreshToken   func(ctx context.Context, refreshToken string)
	afterGetRefreshTokenCounter  uint64
	beforeGetRefreshTokenCounter uint64
	GetRefreshTokenMock          mLoginServiceMockGetRefreshToken

	funcLogin          func(ctx context.Context, username string, password string) (s1 string, err error)
	inspectFuncLogin   func(ctx context.Context, username string, password string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mLoginServiceMockLogin
}

// NewLoginServiceMock returns a mock for service.LoginService
func NewLoginServiceMock(t minimock.Tester) *LoginServiceMock {
	m := &LoginServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetAccessTokenMock = mLoginServiceMockGetAccessToken{mock: m}
	m.GetAccessTokenMock.callArgs = []*LoginServiceMockGetAccessTokenParams{}

	m.GetRefreshTokenMock = mLoginServiceMockGetRefreshToken{mock: m}
	m.GetRefreshTokenMock.callArgs = []*LoginServiceMockGetRefreshTokenParams{}

	m.LoginMock = mLoginServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*LoginServiceMockLoginParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLoginServiceMockGetAccessToken struct {
	mock               *LoginServiceMock
	defaultExpectation *LoginServiceMockGetAccessTokenExpectation
	expectations       []*LoginServiceMockGetAccessTokenExpectation

	callArgs []*LoginServiceMockGetAccessTokenParams
	mutex    sync.RWMutex
}

// LoginServiceMockGetAccessTokenExpectation specifies expectation struct of the LoginService.GetAccessToken
type LoginServiceMockGetAccessTokenExpectation struct {
	mock    *LoginServiceMock
	params  *LoginServiceMockGetAccessTokenParams
	results *LoginServiceMockGetAccessTokenResults
	Counter uint64
}

// LoginServiceMockGetAccessTokenParams contains parameters of the LoginService.GetAccessToken
type LoginServiceMockGetAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// LoginServiceMockGetAccessTokenResults contains results of the LoginService.GetAccessToken
type LoginServiceMockGetAccessTokenResults struct {
	s1  string
	err error
}

// Expect sets up expected params for LoginService.GetAccessToken
func (mmGetAccessToken *mLoginServiceMockGetAccessToken) Expect(ctx context.Context, refreshToken string) *mLoginServiceMockGetAccessToken {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("LoginServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &LoginServiceMockGetAccessTokenExpectation{}
	}

	mmGetAccessToken.defaultExpectation.params = &LoginServiceMockGetAccessTokenParams{ctx, refreshToken}
	for _, e := range mmGetAccessToken.expectations {
		if minimock.Equal(e.params, mmGetAccessToken.defaultExpectation.params) {
			mmGetAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAccessToken.defaultExpectation.params)
		}
	}

	return mmGetAccessToken
}

// Inspect accepts an inspector function that has same arguments as the LoginService.GetAccessToken
func (mmGetAccessToken *mLoginServiceMockGetAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mLoginServiceMockGetAccessToken {
	if mmGetAccessToken.mock.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("Inspect function is already set for LoginServiceMock.GetAccessToken")
	}

	mmGetAccessToken.mock.inspectFuncGetAccessToken = f

	return mmGetAccessToken
}

// Return sets up results that will be returned by LoginService.GetAccessToken
func (mmGetAccessToken *mLoginServiceMockGetAccessToken) Return(s1 string, err error) *LoginServiceMock {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("LoginServiceMock.GetAccessToken mock is already set by Set")
	}

	if mmGetAccessToken.defaultExpectation == nil {
		mmGetAccessToken.defaultExpectation = &LoginServiceMockGetAccessTokenExpectation{mock: mmGetAccessToken.mock}
	}
	mmGetAccessToken.defaultExpectation.results = &LoginServiceMockGetAccessTokenResults{s1, err}
	return mmGetAccessToken.mock
}

// Set uses given function f to mock the LoginService.GetAccessToken method
func (mmGetAccessToken *mLoginServiceMockGetAccessToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *LoginServiceMock {
	if mmGetAccessToken.defaultExpectation != nil {
		mmGetAccessToken.mock.t.Fatalf("Default expectation is already set for the LoginService.GetAccessToken method")
	}

	if len(mmGetAccessToken.expectations) > 0 {
		mmGetAccessToken.mock.t.Fatalf("Some expectations are already set for the LoginService.GetAccessToken method")
	}

	mmGetAccessToken.mock.funcGetAccessToken = f
	return mmGetAccessToken.mock
}

// When sets expectation for the LoginService.GetAccessToken which will trigger the result defined by the following
// Then helper
func (mmGetAccessToken *mLoginServiceMockGetAccessToken) When(ctx context.Context, refreshToken string) *LoginServiceMockGetAccessTokenExpectation {
	if mmGetAccessToken.mock.funcGetAccessToken != nil {
		mmGetAccessToken.mock.t.Fatalf("LoginServiceMock.GetAccessToken mock is already set by Set")
	}

	expectation := &LoginServiceMockGetAccessTokenExpectation{
		mock:   mmGetAccessToken.mock,
		params: &LoginServiceMockGetAccessTokenParams{ctx, refreshToken},
	}
	mmGetAccessToken.expectations = append(mmGetAccessToken.expectations, expectation)
	return expectation
}

// Then sets up LoginService.GetAccessToken return parameters for the expectation previously defined by the When method
func (e *LoginServiceMockGetAccessTokenExpectation) Then(s1 string, err error) *LoginServiceMock {
	e.results = &LoginServiceMockGetAccessTokenResults{s1, err}
	return e.mock
}

// GetAccessToken implements service.LoginService
func (mmGetAccessToken *LoginServiceMock) GetAccessToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetAccessToken.beforeGetAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAccessToken.afterGetAccessTokenCounter, 1)

	if mmGetAccessToken.inspectFuncGetAccessToken != nil {
		mmGetAccessToken.inspectFuncGetAccessToken(ctx, refreshToken)
	}

	mm_params := LoginServiceMockGetAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmGetAccessToken.GetAccessTokenMock.mutex.Lock()
	mmGetAccessToken.GetAccessTokenMock.callArgs = append(mmGetAccessToken.GetAccessTokenMock.callArgs, &mm_params)
	mmGetAccessToken.GetAccessTokenMock.mutex.Unlock()

	for _, e := range mmGetAccessToken.GetAccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetAccessToken.GetAccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAccessToken.GetAccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.params
		mm_got := LoginServiceMockGetAccessTokenParams{ctx, refreshToken}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAccessToken.t.Errorf("LoginServiceMock.GetAccessToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAccessToken.GetAccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAccessToken.t.Fatal("No results are set for the LoginServiceMock.GetAccessToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetAccessToken.funcGetAccessToken != nil {
		return mmGetAccessToken.funcGetAccessToken(ctx, refreshToken)
	}
	mmGetAccessToken.t.Fatalf("Unexpected call to LoginServiceMock.GetAccessToken. %v %v", ctx, refreshToken)
	return
}

// GetAccessTokenAfterCounter returns a count of finished LoginServiceMock.GetAccessToken invocations
func (mmGetAccessToken *LoginServiceMock) GetAccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.afterGetAccessTokenCounter)
}

// GetAccessTokenBeforeCounter returns a count of LoginServiceMock.GetAccessToken invocations
func (mmGetAccessToken *LoginServiceMock) GetAccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAccessToken.beforeGetAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to LoginServiceMock.GetAccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAccessToken *mLoginServiceMockGetAccessToken) Calls() []*LoginServiceMockGetAccessTokenParams {
	mmGetAccessToken.mutex.RLock()

	argCopy := make([]*LoginServiceMockGetAccessTokenParams, len(mmGetAccessToken.callArgs))
	copy(argCopy, mmGetAccessToken.callArgs)

	mmGetAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetAccessTokenDone returns true if the count of the GetAccessToken invocations corresponds
// the number of defined expectations
func (m *LoginServiceMock) MinimockGetAccessTokenDone() bool {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetAccessTokenInspect logs each unmet expectation
func (m *LoginServiceMock) MinimockGetAccessTokenInspect() {
	for _, e := range m.GetAccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoginServiceMock.GetAccessToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetAccessTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter) < 1 {
		if m.GetAccessTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoginServiceMock.GetAccessToken")
		} else {
			m.t.Errorf("Expected call to LoginServiceMock.GetAccessToken with params: %#v", *m.GetAccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAccessToken != nil && mm_atomic.LoadUint64(&m.afterGetAccessTokenCounter) < 1 {
		m.t.Error("Expected call to LoginServiceMock.GetAccessToken")
	}
}

type mLoginServiceMockGetRefreshToken struct {
	mock               *LoginServiceMock
	defaultExpectation *LoginServiceMockGetRefreshTokenExpectation
	expectations       []*LoginServiceMockGetRefreshTokenExpectation

	callArgs []*LoginServiceMockGetRefreshTokenParams
	mutex    sync.RWMutex
}

// LoginServiceMockGetRefreshTokenExpectation specifies expectation struct of the LoginService.GetRefreshToken
type LoginServiceMockGetRefreshTokenExpectation struct {
	mock    *LoginServiceMock
	params  *LoginServiceMockGetRefreshTokenParams
	results *LoginServiceMockGetRefreshTokenResults
	Counter uint64
}

// LoginServiceMockGetRefreshTokenParams contains parameters of the LoginService.GetRefreshToken
type LoginServiceMockGetRefreshTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// LoginServiceMockGetRefreshTokenResults contains results of the LoginService.GetRefreshToken
type LoginServiceMockGetRefreshTokenResults struct {
	s1  string
	err error
}

// Expect sets up expected params for LoginService.GetRefreshToken
func (mmGetRefreshToken *mLoginServiceMockGetRefreshToken) Expect(ctx context.Context, refreshToken string) *mLoginServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("LoginServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &LoginServiceMockGetRefreshTokenExpectation{}
	}

	mmGetRefreshToken.defaultExpectation.params = &LoginServiceMockGetRefreshTokenParams{ctx, refreshToken}
	for _, e := range mmGetRefreshToken.expectations {
		if minimock.Equal(e.params, mmGetRefreshToken.defaultExpectation.params) {
			mmGetRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshToken.defaultExpectation.params)
		}
	}

	return mmGetRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the LoginService.GetRefreshToken
func (mmGetRefreshToken *mLoginServiceMockGetRefreshToken) Inspect(f func(ctx context.Context, refreshToken string)) *mLoginServiceMockGetRefreshToken {
	if mmGetRefreshToken.mock.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("Inspect function is already set for LoginServiceMock.GetRefreshToken")
	}

	mmGetRefreshToken.mock.inspectFuncGetRefreshToken = f

	return mmGetRefreshToken
}

// Return sets up results that will be returned by LoginService.GetRefreshToken
func (mmGetRefreshToken *mLoginServiceMockGetRefreshToken) Return(s1 string, err error) *LoginServiceMock {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("LoginServiceMock.GetRefreshToken mock is already set by Set")
	}

	if mmGetRefreshToken.defaultExpectation == nil {
		mmGetRefreshToken.defaultExpectation = &LoginServiceMockGetRefreshTokenExpectation{mock: mmGetRefreshToken.mock}
	}
	mmGetRefreshToken.defaultExpectation.results = &LoginServiceMockGetRefreshTokenResults{s1, err}
	return mmGetRefreshToken.mock
}

// Set uses given function f to mock the LoginService.GetRefreshToken method
func (mmGetRefreshToken *mLoginServiceMockGetRefreshToken) Set(f func(ctx context.Context, refreshToken string) (s1 string, err error)) *LoginServiceMock {
	if mmGetRefreshToken.defaultExpectation != nil {
		mmGetRefreshToken.mock.t.Fatalf("Default expectation is already set for the LoginService.GetRefreshToken method")
	}

	if len(mmGetRefreshToken.expectations) > 0 {
		mmGetRefreshToken.mock.t.Fatalf("Some expectations are already set for the LoginService.GetRefreshToken method")
	}

	mmGetRefreshToken.mock.funcGetRefreshToken = f
	return mmGetRefreshToken.mock
}

// When sets expectation for the LoginService.GetRefreshToken which will trigger the result defined by the following
// Then helper
func (mmGetRefreshToken *mLoginServiceMockGetRefreshToken) When(ctx context.Context, refreshToken string) *LoginServiceMockGetRefreshTokenExpectation {
	if mmGetRefreshToken.mock.funcGetRefreshToken != nil {
		mmGetRefreshToken.mock.t.Fatalf("LoginServiceMock.GetRefreshToken mock is already set by Set")
	}

	expectation := &LoginServiceMockGetRefreshTokenExpectation{
		mock:   mmGetRefreshToken.mock,
		params: &LoginServiceMockGetRefreshTokenParams{ctx, refreshToken},
	}
	mmGetRefreshToken.expectations = append(mmGetRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up LoginService.GetRefreshToken return parameters for the expectation previously defined by the When method
func (e *LoginServiceMockGetRefreshTokenExpectation) Then(s1 string, err error) *LoginServiceMock {
	e.results = &LoginServiceMockGetRefreshTokenResults{s1, err}
	return e.mock
}

// GetRefreshToken implements service.LoginService
func (mmGetRefreshToken *LoginServiceMock) GetRefreshToken(ctx context.Context, refreshToken string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter, 1)

	if mmGetRefreshToken.inspectFuncGetRefreshToken != nil {
		mmGetRefreshToken.inspectFuncGetRefreshToken(ctx, refreshToken)
	}

	mm_params := LoginServiceMockGetRefreshTokenParams{ctx, refreshToken}

	// Record call args
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Lock()
	mmGetRefreshToken.GetRefreshTokenMock.callArgs = append(mmGetRefreshToken.GetRefreshTokenMock.callArgs, &mm_params)
	mmGetRefreshToken.GetRefreshTokenMock.mutex.Unlock()

	for _, e := range mmGetRefreshToken.GetRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.params
		mm_got := LoginServiceMockGetRefreshTokenParams{ctx, refreshToken}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshToken.t.Errorf("LoginServiceMock.GetRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshToken.GetRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshToken.t.Fatal("No results are set for the LoginServiceMock.GetRefreshToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetRefreshToken.funcGetRefreshToken != nil {
		return mmGetRefreshToken.funcGetRefreshToken(ctx, refreshToken)
	}
	mmGetRefreshToken.t.Fatalf("Unexpected call to LoginServiceMock.GetRefreshToken. %v %v", ctx, refreshToken)
	return
}

// GetRefreshTokenAfterCounter returns a count of finished LoginServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *LoginServiceMock) GetRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.afterGetRefreshTokenCounter)
}

// GetRefreshTokenBeforeCounter returns a count of LoginServiceMock.GetRefreshToken invocations
func (mmGetRefreshToken *LoginServiceMock) GetRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshToken.beforeGetRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to LoginServiceMock.GetRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshToken *mLoginServiceMockGetRefreshToken) Calls() []*LoginServiceMockGetRefreshTokenParams {
	mmGetRefreshToken.mutex.RLock()

	argCopy := make([]*LoginServiceMockGetRefreshTokenParams, len(mmGetRefreshToken.callArgs))
	copy(argCopy, mmGetRefreshToken.callArgs)

	mmGetRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenDone returns true if the count of the GetRefreshToken invocations corresponds
// the number of defined expectations
func (m *LoginServiceMock) MinimockGetRefreshTokenDone() bool {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRefreshTokenInspect logs each unmet expectation
func (m *LoginServiceMock) MinimockGetRefreshTokenInspect() {
	for _, e := range m.GetRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoginServiceMock.GetRefreshToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter) < 1 {
		if m.GetRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoginServiceMock.GetRefreshToken")
		} else {
			m.t.Errorf("Expected call to LoginServiceMock.GetRefreshToken with params: %#v", *m.GetRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshToken != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenCounter) < 1 {
		m.t.Error("Expected call to LoginServiceMock.GetRefreshToken")
	}
}

type mLoginServiceMockLogin struct {
	mock               *LoginServiceMock
	defaultExpectation *LoginServiceMockLoginExpectation
	expectations       []*LoginServiceMockLoginExpectation

	callArgs []*LoginServiceMockLoginParams
	mutex    sync.RWMutex
}

// LoginServiceMockLoginExpectation specifies expectation struct of the LoginService.Login
type LoginServiceMockLoginExpectation struct {
	mock    *LoginServiceMock
	params  *LoginServiceMockLoginParams
	results *LoginServiceMockLoginResults
	Counter uint64
}

// LoginServiceMockLoginParams contains parameters of the LoginService.Login
type LoginServiceMockLoginParams struct {
	ctx      context.Context
	username string
	password string
}

// LoginServiceMockLoginResults contains results of the LoginService.Login
type LoginServiceMockLoginResults struct {
	s1  string
	err error
}

// Expect sets up expected params for LoginService.Login
func (mmLogin *mLoginServiceMockLogin) Expect(ctx context.Context, username string, password string) *mLoginServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("LoginServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &LoginServiceMockLoginExpectation{}
	}

	mmLogin.defaultExpectation.params = &LoginServiceMockLoginParams{ctx, username, password}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the LoginService.Login
func (mmLogin *mLoginServiceMockLogin) Inspect(f func(ctx context.Context, username string, password string)) *mLoginServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for LoginServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by LoginService.Login
func (mmLogin *mLoginServiceMockLogin) Return(s1 string, err error) *LoginServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("LoginServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &LoginServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &LoginServiceMockLoginResults{s1, err}
	return mmLogin.mock
}

// Set uses given function f to mock the LoginService.Login method
func (mmLogin *mLoginServiceMockLogin) Set(f func(ctx context.Context, username string, password string) (s1 string, err error)) *LoginServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the LoginService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the LoginService.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the LoginService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mLoginServiceMockLogin) When(ctx context.Context, username string, password string) *LoginServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("LoginServiceMock.Login mock is already set by Set")
	}

	expectation := &LoginServiceMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &LoginServiceMockLoginParams{ctx, username, password},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up LoginService.Login return parameters for the expectation previously defined by the When method
func (e *LoginServiceMockLoginExpectation) Then(s1 string, err error) *LoginServiceMock {
	e.results = &LoginServiceMockLoginResults{s1, err}
	return e.mock
}

// Login implements service.LoginService
func (mmLogin *LoginServiceMock) Login(ctx context.Context, username string, password string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, username, password)
	}

	mm_params := LoginServiceMockLoginParams{ctx, username, password}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_got := LoginServiceMockLoginParams{ctx, username, password}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("LoginServiceMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the LoginServiceMock.Login")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, username, password)
	}
	mmLogin.t.Fatalf("Unexpected call to LoginServiceMock.Login. %v %v %v", ctx, username, password)
	return
}

// LoginAfterCounter returns a count of finished LoginServiceMock.Login invocations
func (mmLogin *LoginServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of LoginServiceMock.Login invocations
func (mmLogin *LoginServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to LoginServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mLoginServiceMockLogin) Calls() []*LoginServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*LoginServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *LoginServiceMock) MinimockLoginDone() bool {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockLoginInspect logs each unmet expectation
func (m *LoginServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LoginServiceMock.Login with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to LoginServiceMock.Login")
		} else {
			m.t.Errorf("Expected call to LoginServiceMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		m.t.Error("Expected call to LoginServiceMock.Login")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LoginServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetAccessTokenInspect()

			m.MinimockGetRefreshTokenInspect()

			m.MinimockLoginInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LoginServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LoginServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetAccessTokenDone() &&
		m.MinimockGetRefreshTokenDone() &&
		m.MinimockLoginDone()
}
