// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/semho/chat-microservices/auth/internal/service.AccessService -o access_service_minimock.go -n AccessServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/semho/chat-microservices/auth/internal/model"
)

// AccessServiceMock implements service.AccessService
type AccessServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAccessibleRoles          func(ctx context.Context) (m1 map[string]int, err error)
	inspectFuncAccessibleRoles   func(ctx context.Context)
	afterAccessibleRolesCounter  uint64
	beforeAccessibleRolesCounter uint64
	AccessibleRolesMock          mAccessServiceMockAccessibleRoles

	funcCheck          func(ctx context.Context, endpoint string) (err error)
	inspectFuncCheck   func(ctx context.Context, endpoint string)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mAccessServiceMockCheck

	funcCreateAccess          func(ctx context.Context, access *model.Access) (i1 int64, err error)
	inspectFuncCreateAccess   func(ctx context.Context, access *model.Access)
	afterCreateAccessCounter  uint64
	beforeCreateAccessCounter uint64
	CreateAccessMock          mAccessServiceMockCreateAccess

	funcDeleteAccess          func(ctx context.Context, id int64) (err error)
	inspectFuncDeleteAccess   func(ctx context.Context, id int64)
	afterDeleteAccessCounter  uint64
	beforeDeleteAccessCounter uint64
	DeleteAccessMock          mAccessServiceMockDeleteAccess

	funcGetListAccess          func(ctx context.Context, pageNumber uint64, pageSize uint64) (apa1 []*model.Access, err error)
	inspectFuncGetListAccess   func(ctx context.Context, pageNumber uint64, pageSize uint64)
	afterGetListAccessCounter  uint64
	beforeGetListAccessCounter uint64
	GetListAccessMock          mAccessServiceMockGetListAccess

	funcUpdateAccess          func(ctx context.Context, access *model.Access) (err error)
	inspectFuncUpdateAccess   func(ctx context.Context, access *model.Access)
	afterUpdateAccessCounter  uint64
	beforeUpdateAccessCounter uint64
	UpdateAccessMock          mAccessServiceMockUpdateAccess
}

// NewAccessServiceMock returns a mock for service.AccessService
func NewAccessServiceMock(t minimock.Tester) *AccessServiceMock {
	m := &AccessServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccessibleRolesMock = mAccessServiceMockAccessibleRoles{mock: m}
	m.AccessibleRolesMock.callArgs = []*AccessServiceMockAccessibleRolesParams{}

	m.CheckMock = mAccessServiceMockCheck{mock: m}
	m.CheckMock.callArgs = []*AccessServiceMockCheckParams{}

	m.CreateAccessMock = mAccessServiceMockCreateAccess{mock: m}
	m.CreateAccessMock.callArgs = []*AccessServiceMockCreateAccessParams{}

	m.DeleteAccessMock = mAccessServiceMockDeleteAccess{mock: m}
	m.DeleteAccessMock.callArgs = []*AccessServiceMockDeleteAccessParams{}

	m.GetListAccessMock = mAccessServiceMockGetListAccess{mock: m}
	m.GetListAccessMock.callArgs = []*AccessServiceMockGetListAccessParams{}

	m.UpdateAccessMock = mAccessServiceMockUpdateAccess{mock: m}
	m.UpdateAccessMock.callArgs = []*AccessServiceMockUpdateAccessParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAccessServiceMockAccessibleRoles struct {
	mock               *AccessServiceMock
	defaultExpectation *AccessServiceMockAccessibleRolesExpectation
	expectations       []*AccessServiceMockAccessibleRolesExpectation

	callArgs []*AccessServiceMockAccessibleRolesParams
	mutex    sync.RWMutex
}

// AccessServiceMockAccessibleRolesExpectation specifies expectation struct of the AccessService.AccessibleRoles
type AccessServiceMockAccessibleRolesExpectation struct {
	mock    *AccessServiceMock
	params  *AccessServiceMockAccessibleRolesParams
	results *AccessServiceMockAccessibleRolesResults
	Counter uint64
}

// AccessServiceMockAccessibleRolesParams contains parameters of the AccessService.AccessibleRoles
type AccessServiceMockAccessibleRolesParams struct {
	ctx context.Context
}

// AccessServiceMockAccessibleRolesResults contains results of the AccessService.AccessibleRoles
type AccessServiceMockAccessibleRolesResults struct {
	m1  map[string]int
	err error
}

// Expect sets up expected params for AccessService.AccessibleRoles
func (mmAccessibleRoles *mAccessServiceMockAccessibleRoles) Expect(ctx context.Context) *mAccessServiceMockAccessibleRoles {
	if mmAccessibleRoles.mock.funcAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("AccessServiceMock.AccessibleRoles mock is already set by Set")
	}

	if mmAccessibleRoles.defaultExpectation == nil {
		mmAccessibleRoles.defaultExpectation = &AccessServiceMockAccessibleRolesExpectation{}
	}

	mmAccessibleRoles.defaultExpectation.params = &AccessServiceMockAccessibleRolesParams{ctx}
	for _, e := range mmAccessibleRoles.expectations {
		if minimock.Equal(e.params, mmAccessibleRoles.defaultExpectation.params) {
			mmAccessibleRoles.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAccessibleRoles.defaultExpectation.params)
		}
	}

	return mmAccessibleRoles
}

// Inspect accepts an inspector function that has same arguments as the AccessService.AccessibleRoles
func (mmAccessibleRoles *mAccessServiceMockAccessibleRoles) Inspect(f func(ctx context.Context)) *mAccessServiceMockAccessibleRoles {
	if mmAccessibleRoles.mock.inspectFuncAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("Inspect function is already set for AccessServiceMock.AccessibleRoles")
	}

	mmAccessibleRoles.mock.inspectFuncAccessibleRoles = f

	return mmAccessibleRoles
}

// Return sets up results that will be returned by AccessService.AccessibleRoles
func (mmAccessibleRoles *mAccessServiceMockAccessibleRoles) Return(m1 map[string]int, err error) *AccessServiceMock {
	if mmAccessibleRoles.mock.funcAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("AccessServiceMock.AccessibleRoles mock is already set by Set")
	}

	if mmAccessibleRoles.defaultExpectation == nil {
		mmAccessibleRoles.defaultExpectation = &AccessServiceMockAccessibleRolesExpectation{mock: mmAccessibleRoles.mock}
	}
	mmAccessibleRoles.defaultExpectation.results = &AccessServiceMockAccessibleRolesResults{m1, err}
	return mmAccessibleRoles.mock
}

// Set uses given function f to mock the AccessService.AccessibleRoles method
func (mmAccessibleRoles *mAccessServiceMockAccessibleRoles) Set(f func(ctx context.Context) (m1 map[string]int, err error)) *AccessServiceMock {
	if mmAccessibleRoles.defaultExpectation != nil {
		mmAccessibleRoles.mock.t.Fatalf("Default expectation is already set for the AccessService.AccessibleRoles method")
	}

	if len(mmAccessibleRoles.expectations) > 0 {
		mmAccessibleRoles.mock.t.Fatalf("Some expectations are already set for the AccessService.AccessibleRoles method")
	}

	mmAccessibleRoles.mock.funcAccessibleRoles = f
	return mmAccessibleRoles.mock
}

// When sets expectation for the AccessService.AccessibleRoles which will trigger the result defined by the following
// Then helper
func (mmAccessibleRoles *mAccessServiceMockAccessibleRoles) When(ctx context.Context) *AccessServiceMockAccessibleRolesExpectation {
	if mmAccessibleRoles.mock.funcAccessibleRoles != nil {
		mmAccessibleRoles.mock.t.Fatalf("AccessServiceMock.AccessibleRoles mock is already set by Set")
	}

	expectation := &AccessServiceMockAccessibleRolesExpectation{
		mock:   mmAccessibleRoles.mock,
		params: &AccessServiceMockAccessibleRolesParams{ctx},
	}
	mmAccessibleRoles.expectations = append(mmAccessibleRoles.expectations, expectation)
	return expectation
}

// Then sets up AccessService.AccessibleRoles return parameters for the expectation previously defined by the When method
func (e *AccessServiceMockAccessibleRolesExpectation) Then(m1 map[string]int, err error) *AccessServiceMock {
	e.results = &AccessServiceMockAccessibleRolesResults{m1, err}
	return e.mock
}

// AccessibleRoles implements service.AccessService
func (mmAccessibleRoles *AccessServiceMock) AccessibleRoles(ctx context.Context) (m1 map[string]int, err error) {
	mm_atomic.AddUint64(&mmAccessibleRoles.beforeAccessibleRolesCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessibleRoles.afterAccessibleRolesCounter, 1)

	if mmAccessibleRoles.inspectFuncAccessibleRoles != nil {
		mmAccessibleRoles.inspectFuncAccessibleRoles(ctx)
	}

	mm_params := AccessServiceMockAccessibleRolesParams{ctx}

	// Record call args
	mmAccessibleRoles.AccessibleRolesMock.mutex.Lock()
	mmAccessibleRoles.AccessibleRolesMock.callArgs = append(mmAccessibleRoles.AccessibleRolesMock.callArgs, &mm_params)
	mmAccessibleRoles.AccessibleRolesMock.mutex.Unlock()

	for _, e := range mmAccessibleRoles.AccessibleRolesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmAccessibleRoles.AccessibleRolesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessibleRoles.AccessibleRolesMock.defaultExpectation.Counter, 1)
		mm_want := mmAccessibleRoles.AccessibleRolesMock.defaultExpectation.params
		mm_got := AccessServiceMockAccessibleRolesParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAccessibleRoles.t.Errorf("AccessServiceMock.AccessibleRoles got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAccessibleRoles.AccessibleRolesMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessibleRoles.t.Fatal("No results are set for the AccessServiceMock.AccessibleRoles")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmAccessibleRoles.funcAccessibleRoles != nil {
		return mmAccessibleRoles.funcAccessibleRoles(ctx)
	}
	mmAccessibleRoles.t.Fatalf("Unexpected call to AccessServiceMock.AccessibleRoles. %v", ctx)
	return
}

// AccessibleRolesAfterCounter returns a count of finished AccessServiceMock.AccessibleRoles invocations
func (mmAccessibleRoles *AccessServiceMock) AccessibleRolesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessibleRoles.afterAccessibleRolesCounter)
}

// AccessibleRolesBeforeCounter returns a count of AccessServiceMock.AccessibleRoles invocations
func (mmAccessibleRoles *AccessServiceMock) AccessibleRolesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessibleRoles.beforeAccessibleRolesCounter)
}

// Calls returns a list of arguments used in each call to AccessServiceMock.AccessibleRoles.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAccessibleRoles *mAccessServiceMockAccessibleRoles) Calls() []*AccessServiceMockAccessibleRolesParams {
	mmAccessibleRoles.mutex.RLock()

	argCopy := make([]*AccessServiceMockAccessibleRolesParams, len(mmAccessibleRoles.callArgs))
	copy(argCopy, mmAccessibleRoles.callArgs)

	mmAccessibleRoles.mutex.RUnlock()

	return argCopy
}

// MinimockAccessibleRolesDone returns true if the count of the AccessibleRoles invocations corresponds
// the number of defined expectations
func (m *AccessServiceMock) MinimockAccessibleRolesDone() bool {
	for _, e := range m.AccessibleRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccessibleRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessibleRoles != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		return false
	}
	return true
}

// MinimockAccessibleRolesInspect logs each unmet expectation
func (m *AccessServiceMock) MinimockAccessibleRolesInspect() {
	for _, e := range m.AccessibleRolesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessServiceMock.AccessibleRoles with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AccessibleRolesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		if m.AccessibleRolesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessServiceMock.AccessibleRoles")
		} else {
			m.t.Errorf("Expected call to AccessServiceMock.AccessibleRoles with params: %#v", *m.AccessibleRolesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessibleRoles != nil && mm_atomic.LoadUint64(&m.afterAccessibleRolesCounter) < 1 {
		m.t.Error("Expected call to AccessServiceMock.AccessibleRoles")
	}
}

type mAccessServiceMockCheck struct {
	mock               *AccessServiceMock
	defaultExpectation *AccessServiceMockCheckExpectation
	expectations       []*AccessServiceMockCheckExpectation

	callArgs []*AccessServiceMockCheckParams
	mutex    sync.RWMutex
}

// AccessServiceMockCheckExpectation specifies expectation struct of the AccessService.Check
type AccessServiceMockCheckExpectation struct {
	mock    *AccessServiceMock
	params  *AccessServiceMockCheckParams
	results *AccessServiceMockCheckResults
	Counter uint64
}

// AccessServiceMockCheckParams contains parameters of the AccessService.Check
type AccessServiceMockCheckParams struct {
	ctx      context.Context
	endpoint string
}

// AccessServiceMockCheckResults contains results of the AccessService.Check
type AccessServiceMockCheckResults struct {
	err error
}

// Expect sets up expected params for AccessService.Check
func (mmCheck *mAccessServiceMockCheck) Expect(ctx context.Context, endpoint string) *mAccessServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AccessServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AccessServiceMockCheckExpectation{}
	}

	mmCheck.defaultExpectation.params = &AccessServiceMockCheckParams{ctx, endpoint}
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the AccessService.Check
func (mmCheck *mAccessServiceMockCheck) Inspect(f func(ctx context.Context, endpoint string)) *mAccessServiceMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for AccessServiceMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by AccessService.Check
func (mmCheck *mAccessServiceMockCheck) Return(err error) *AccessServiceMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AccessServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AccessServiceMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &AccessServiceMockCheckResults{err}
	return mmCheck.mock
}

// Set uses given function f to mock the AccessService.Check method
func (mmCheck *mAccessServiceMockCheck) Set(f func(ctx context.Context, endpoint string) (err error)) *AccessServiceMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the AccessService.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the AccessService.Check method")
	}

	mmCheck.mock.funcCheck = f
	return mmCheck.mock
}

// When sets expectation for the AccessService.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mAccessServiceMockCheck) When(ctx context.Context, endpoint string) *AccessServiceMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AccessServiceMock.Check mock is already set by Set")
	}

	expectation := &AccessServiceMockCheckExpectation{
		mock:   mmCheck.mock,
		params: &AccessServiceMockCheckParams{ctx, endpoint},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up AccessService.Check return parameters for the expectation previously defined by the When method
func (e *AccessServiceMockCheckExpectation) Then(err error) *AccessServiceMock {
	e.results = &AccessServiceMockCheckResults{err}
	return e.mock
}

// Check implements service.AccessService
func (mmCheck *AccessServiceMock) Check(ctx context.Context, endpoint string) (err error) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(ctx, endpoint)
	}

	mm_params := AccessServiceMockCheckParams{ctx, endpoint}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, &mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_got := AccessServiceMockCheckParams{ctx, endpoint}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("AccessServiceMock.Check got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the AccessServiceMock.Check")
		}
		return (*mm_results).err
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(ctx, endpoint)
	}
	mmCheck.t.Fatalf("Unexpected call to AccessServiceMock.Check. %v %v", ctx, endpoint)
	return
}

// CheckAfterCounter returns a count of finished AccessServiceMock.Check invocations
func (mmCheck *AccessServiceMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of AccessServiceMock.Check invocations
func (mmCheck *AccessServiceMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to AccessServiceMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mAccessServiceMockCheck) Calls() []*AccessServiceMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*AccessServiceMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *AccessServiceMock) MinimockCheckDone() bool {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckInspect logs each unmet expectation
func (m *AccessServiceMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessServiceMock.Check with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessServiceMock.Check")
		} else {
			m.t.Errorf("Expected call to AccessServiceMock.Check with params: %#v", *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && mm_atomic.LoadUint64(&m.afterCheckCounter) < 1 {
		m.t.Error("Expected call to AccessServiceMock.Check")
	}
}

type mAccessServiceMockCreateAccess struct {
	mock               *AccessServiceMock
	defaultExpectation *AccessServiceMockCreateAccessExpectation
	expectations       []*AccessServiceMockCreateAccessExpectation

	callArgs []*AccessServiceMockCreateAccessParams
	mutex    sync.RWMutex
}

// AccessServiceMockCreateAccessExpectation specifies expectation struct of the AccessService.CreateAccess
type AccessServiceMockCreateAccessExpectation struct {
	mock    *AccessServiceMock
	params  *AccessServiceMockCreateAccessParams
	results *AccessServiceMockCreateAccessResults
	Counter uint64
}

// AccessServiceMockCreateAccessParams contains parameters of the AccessService.CreateAccess
type AccessServiceMockCreateAccessParams struct {
	ctx    context.Context
	access *model.Access
}

// AccessServiceMockCreateAccessResults contains results of the AccessService.CreateAccess
type AccessServiceMockCreateAccessResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for AccessService.CreateAccess
func (mmCreateAccess *mAccessServiceMockCreateAccess) Expect(ctx context.Context, access *model.Access) *mAccessServiceMockCreateAccess {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("AccessServiceMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &AccessServiceMockCreateAccessExpectation{}
	}

	mmCreateAccess.defaultExpectation.params = &AccessServiceMockCreateAccessParams{ctx, access}
	for _, e := range mmCreateAccess.expectations {
		if minimock.Equal(e.params, mmCreateAccess.defaultExpectation.params) {
			mmCreateAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAccess.defaultExpectation.params)
		}
	}

	return mmCreateAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessService.CreateAccess
func (mmCreateAccess *mAccessServiceMockCreateAccess) Inspect(f func(ctx context.Context, access *model.Access)) *mAccessServiceMockCreateAccess {
	if mmCreateAccess.mock.inspectFuncCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("Inspect function is already set for AccessServiceMock.CreateAccess")
	}

	mmCreateAccess.mock.inspectFuncCreateAccess = f

	return mmCreateAccess
}

// Return sets up results that will be returned by AccessService.CreateAccess
func (mmCreateAccess *mAccessServiceMockCreateAccess) Return(i1 int64, err error) *AccessServiceMock {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("AccessServiceMock.CreateAccess mock is already set by Set")
	}

	if mmCreateAccess.defaultExpectation == nil {
		mmCreateAccess.defaultExpectation = &AccessServiceMockCreateAccessExpectation{mock: mmCreateAccess.mock}
	}
	mmCreateAccess.defaultExpectation.results = &AccessServiceMockCreateAccessResults{i1, err}
	return mmCreateAccess.mock
}

// Set uses given function f to mock the AccessService.CreateAccess method
func (mmCreateAccess *mAccessServiceMockCreateAccess) Set(f func(ctx context.Context, access *model.Access) (i1 int64, err error)) *AccessServiceMock {
	if mmCreateAccess.defaultExpectation != nil {
		mmCreateAccess.mock.t.Fatalf("Default expectation is already set for the AccessService.CreateAccess method")
	}

	if len(mmCreateAccess.expectations) > 0 {
		mmCreateAccess.mock.t.Fatalf("Some expectations are already set for the AccessService.CreateAccess method")
	}

	mmCreateAccess.mock.funcCreateAccess = f
	return mmCreateAccess.mock
}

// When sets expectation for the AccessService.CreateAccess which will trigger the result defined by the following
// Then helper
func (mmCreateAccess *mAccessServiceMockCreateAccess) When(ctx context.Context, access *model.Access) *AccessServiceMockCreateAccessExpectation {
	if mmCreateAccess.mock.funcCreateAccess != nil {
		mmCreateAccess.mock.t.Fatalf("AccessServiceMock.CreateAccess mock is already set by Set")
	}

	expectation := &AccessServiceMockCreateAccessExpectation{
		mock:   mmCreateAccess.mock,
		params: &AccessServiceMockCreateAccessParams{ctx, access},
	}
	mmCreateAccess.expectations = append(mmCreateAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessService.CreateAccess return parameters for the expectation previously defined by the When method
func (e *AccessServiceMockCreateAccessExpectation) Then(i1 int64, err error) *AccessServiceMock {
	e.results = &AccessServiceMockCreateAccessResults{i1, err}
	return e.mock
}

// CreateAccess implements service.AccessService
func (mmCreateAccess *AccessServiceMock) CreateAccess(ctx context.Context, access *model.Access) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateAccess.beforeCreateAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAccess.afterCreateAccessCounter, 1)

	if mmCreateAccess.inspectFuncCreateAccess != nil {
		mmCreateAccess.inspectFuncCreateAccess(ctx, access)
	}

	mm_params := AccessServiceMockCreateAccessParams{ctx, access}

	// Record call args
	mmCreateAccess.CreateAccessMock.mutex.Lock()
	mmCreateAccess.CreateAccessMock.callArgs = append(mmCreateAccess.CreateAccessMock.callArgs, &mm_params)
	mmCreateAccess.CreateAccessMock.mutex.Unlock()

	for _, e := range mmCreateAccess.CreateAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateAccess.CreateAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAccess.CreateAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAccess.CreateAccessMock.defaultExpectation.params
		mm_got := AccessServiceMockCreateAccessParams{ctx, access}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAccess.t.Errorf("AccessServiceMock.CreateAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAccess.CreateAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAccess.t.Fatal("No results are set for the AccessServiceMock.CreateAccess")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateAccess.funcCreateAccess != nil {
		return mmCreateAccess.funcCreateAccess(ctx, access)
	}
	mmCreateAccess.t.Fatalf("Unexpected call to AccessServiceMock.CreateAccess. %v %v", ctx, access)
	return
}

// CreateAccessAfterCounter returns a count of finished AccessServiceMock.CreateAccess invocations
func (mmCreateAccess *AccessServiceMock) CreateAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.afterCreateAccessCounter)
}

// CreateAccessBeforeCounter returns a count of AccessServiceMock.CreateAccess invocations
func (mmCreateAccess *AccessServiceMock) CreateAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAccess.beforeCreateAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessServiceMock.CreateAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAccess *mAccessServiceMockCreateAccess) Calls() []*AccessServiceMockCreateAccessParams {
	mmCreateAccess.mutex.RLock()

	argCopy := make([]*AccessServiceMockCreateAccessParams, len(mmCreateAccess.callArgs))
	copy(argCopy, mmCreateAccess.callArgs)

	mmCreateAccess.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAccessDone returns true if the count of the CreateAccess invocations corresponds
// the number of defined expectations
func (m *AccessServiceMock) MinimockCreateAccessDone() bool {
	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccess != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateAccessInspect logs each unmet expectation
func (m *AccessServiceMock) MinimockCreateAccessInspect() {
	for _, e := range m.CreateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessServiceMock.CreateAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		if m.CreateAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessServiceMock.CreateAccess")
		} else {
			m.t.Errorf("Expected call to AccessServiceMock.CreateAccess with params: %#v", *m.CreateAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAccess != nil && mm_atomic.LoadUint64(&m.afterCreateAccessCounter) < 1 {
		m.t.Error("Expected call to AccessServiceMock.CreateAccess")
	}
}

type mAccessServiceMockDeleteAccess struct {
	mock               *AccessServiceMock
	defaultExpectation *AccessServiceMockDeleteAccessExpectation
	expectations       []*AccessServiceMockDeleteAccessExpectation

	callArgs []*AccessServiceMockDeleteAccessParams
	mutex    sync.RWMutex
}

// AccessServiceMockDeleteAccessExpectation specifies expectation struct of the AccessService.DeleteAccess
type AccessServiceMockDeleteAccessExpectation struct {
	mock    *AccessServiceMock
	params  *AccessServiceMockDeleteAccessParams
	results *AccessServiceMockDeleteAccessResults
	Counter uint64
}

// AccessServiceMockDeleteAccessParams contains parameters of the AccessService.DeleteAccess
type AccessServiceMockDeleteAccessParams struct {
	ctx context.Context
	id  int64
}

// AccessServiceMockDeleteAccessResults contains results of the AccessService.DeleteAccess
type AccessServiceMockDeleteAccessResults struct {
	err error
}

// Expect sets up expected params for AccessService.DeleteAccess
func (mmDeleteAccess *mAccessServiceMockDeleteAccess) Expect(ctx context.Context, id int64) *mAccessServiceMockDeleteAccess {
	if mmDeleteAccess.mock.funcDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("AccessServiceMock.DeleteAccess mock is already set by Set")
	}

	if mmDeleteAccess.defaultExpectation == nil {
		mmDeleteAccess.defaultExpectation = &AccessServiceMockDeleteAccessExpectation{}
	}

	mmDeleteAccess.defaultExpectation.params = &AccessServiceMockDeleteAccessParams{ctx, id}
	for _, e := range mmDeleteAccess.expectations {
		if minimock.Equal(e.params, mmDeleteAccess.defaultExpectation.params) {
			mmDeleteAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAccess.defaultExpectation.params)
		}
	}

	return mmDeleteAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessService.DeleteAccess
func (mmDeleteAccess *mAccessServiceMockDeleteAccess) Inspect(f func(ctx context.Context, id int64)) *mAccessServiceMockDeleteAccess {
	if mmDeleteAccess.mock.inspectFuncDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("Inspect function is already set for AccessServiceMock.DeleteAccess")
	}

	mmDeleteAccess.mock.inspectFuncDeleteAccess = f

	return mmDeleteAccess
}

// Return sets up results that will be returned by AccessService.DeleteAccess
func (mmDeleteAccess *mAccessServiceMockDeleteAccess) Return(err error) *AccessServiceMock {
	if mmDeleteAccess.mock.funcDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("AccessServiceMock.DeleteAccess mock is already set by Set")
	}

	if mmDeleteAccess.defaultExpectation == nil {
		mmDeleteAccess.defaultExpectation = &AccessServiceMockDeleteAccessExpectation{mock: mmDeleteAccess.mock}
	}
	mmDeleteAccess.defaultExpectation.results = &AccessServiceMockDeleteAccessResults{err}
	return mmDeleteAccess.mock
}

// Set uses given function f to mock the AccessService.DeleteAccess method
func (mmDeleteAccess *mAccessServiceMockDeleteAccess) Set(f func(ctx context.Context, id int64) (err error)) *AccessServiceMock {
	if mmDeleteAccess.defaultExpectation != nil {
		mmDeleteAccess.mock.t.Fatalf("Default expectation is already set for the AccessService.DeleteAccess method")
	}

	if len(mmDeleteAccess.expectations) > 0 {
		mmDeleteAccess.mock.t.Fatalf("Some expectations are already set for the AccessService.DeleteAccess method")
	}

	mmDeleteAccess.mock.funcDeleteAccess = f
	return mmDeleteAccess.mock
}

// When sets expectation for the AccessService.DeleteAccess which will trigger the result defined by the following
// Then helper
func (mmDeleteAccess *mAccessServiceMockDeleteAccess) When(ctx context.Context, id int64) *AccessServiceMockDeleteAccessExpectation {
	if mmDeleteAccess.mock.funcDeleteAccess != nil {
		mmDeleteAccess.mock.t.Fatalf("AccessServiceMock.DeleteAccess mock is already set by Set")
	}

	expectation := &AccessServiceMockDeleteAccessExpectation{
		mock:   mmDeleteAccess.mock,
		params: &AccessServiceMockDeleteAccessParams{ctx, id},
	}
	mmDeleteAccess.expectations = append(mmDeleteAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessService.DeleteAccess return parameters for the expectation previously defined by the When method
func (e *AccessServiceMockDeleteAccessExpectation) Then(err error) *AccessServiceMock {
	e.results = &AccessServiceMockDeleteAccessResults{err}
	return e.mock
}

// DeleteAccess implements service.AccessService
func (mmDeleteAccess *AccessServiceMock) DeleteAccess(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteAccess.beforeDeleteAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAccess.afterDeleteAccessCounter, 1)

	if mmDeleteAccess.inspectFuncDeleteAccess != nil {
		mmDeleteAccess.inspectFuncDeleteAccess(ctx, id)
	}

	mm_params := AccessServiceMockDeleteAccessParams{ctx, id}

	// Record call args
	mmDeleteAccess.DeleteAccessMock.mutex.Lock()
	mmDeleteAccess.DeleteAccessMock.callArgs = append(mmDeleteAccess.DeleteAccessMock.callArgs, &mm_params)
	mmDeleteAccess.DeleteAccessMock.mutex.Unlock()

	for _, e := range mmDeleteAccess.DeleteAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAccess.DeleteAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAccess.DeleteAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAccess.DeleteAccessMock.defaultExpectation.params
		mm_got := AccessServiceMockDeleteAccessParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAccess.t.Errorf("AccessServiceMock.DeleteAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAccess.DeleteAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAccess.t.Fatal("No results are set for the AccessServiceMock.DeleteAccess")
		}
		return (*mm_results).err
	}
	if mmDeleteAccess.funcDeleteAccess != nil {
		return mmDeleteAccess.funcDeleteAccess(ctx, id)
	}
	mmDeleteAccess.t.Fatalf("Unexpected call to AccessServiceMock.DeleteAccess. %v %v", ctx, id)
	return
}

// DeleteAccessAfterCounter returns a count of finished AccessServiceMock.DeleteAccess invocations
func (mmDeleteAccess *AccessServiceMock) DeleteAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAccess.afterDeleteAccessCounter)
}

// DeleteAccessBeforeCounter returns a count of AccessServiceMock.DeleteAccess invocations
func (mmDeleteAccess *AccessServiceMock) DeleteAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAccess.beforeDeleteAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessServiceMock.DeleteAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAccess *mAccessServiceMockDeleteAccess) Calls() []*AccessServiceMockDeleteAccessParams {
	mmDeleteAccess.mutex.RLock()

	argCopy := make([]*AccessServiceMockDeleteAccessParams, len(mmDeleteAccess.callArgs))
	copy(argCopy, mmDeleteAccess.callArgs)

	mmDeleteAccess.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAccessDone returns true if the count of the DeleteAccess invocations corresponds
// the number of defined expectations
func (m *AccessServiceMock) MinimockDeleteAccessDone() bool {
	for _, e := range m.DeleteAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAccess != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteAccessInspect logs each unmet expectation
func (m *AccessServiceMock) MinimockDeleteAccessInspect() {
	for _, e := range m.DeleteAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessServiceMock.DeleteAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		if m.DeleteAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessServiceMock.DeleteAccess")
		} else {
			m.t.Errorf("Expected call to AccessServiceMock.DeleteAccess with params: %#v", *m.DeleteAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAccess != nil && mm_atomic.LoadUint64(&m.afterDeleteAccessCounter) < 1 {
		m.t.Error("Expected call to AccessServiceMock.DeleteAccess")
	}
}

type mAccessServiceMockGetListAccess struct {
	mock               *AccessServiceMock
	defaultExpectation *AccessServiceMockGetListAccessExpectation
	expectations       []*AccessServiceMockGetListAccessExpectation

	callArgs []*AccessServiceMockGetListAccessParams
	mutex    sync.RWMutex
}

// AccessServiceMockGetListAccessExpectation specifies expectation struct of the AccessService.GetListAccess
type AccessServiceMockGetListAccessExpectation struct {
	mock    *AccessServiceMock
	params  *AccessServiceMockGetListAccessParams
	results *AccessServiceMockGetListAccessResults
	Counter uint64
}

// AccessServiceMockGetListAccessParams contains parameters of the AccessService.GetListAccess
type AccessServiceMockGetListAccessParams struct {
	ctx        context.Context
	pageNumber uint64
	pageSize   uint64
}

// AccessServiceMockGetListAccessResults contains results of the AccessService.GetListAccess
type AccessServiceMockGetListAccessResults struct {
	apa1 []*model.Access
	err  error
}

// Expect sets up expected params for AccessService.GetListAccess
func (mmGetListAccess *mAccessServiceMockGetListAccess) Expect(ctx context.Context, pageNumber uint64, pageSize uint64) *mAccessServiceMockGetListAccess {
	if mmGetListAccess.mock.funcGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("AccessServiceMock.GetListAccess mock is already set by Set")
	}

	if mmGetListAccess.defaultExpectation == nil {
		mmGetListAccess.defaultExpectation = &AccessServiceMockGetListAccessExpectation{}
	}

	mmGetListAccess.defaultExpectation.params = &AccessServiceMockGetListAccessParams{ctx, pageNumber, pageSize}
	for _, e := range mmGetListAccess.expectations {
		if minimock.Equal(e.params, mmGetListAccess.defaultExpectation.params) {
			mmGetListAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListAccess.defaultExpectation.params)
		}
	}

	return mmGetListAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessService.GetListAccess
func (mmGetListAccess *mAccessServiceMockGetListAccess) Inspect(f func(ctx context.Context, pageNumber uint64, pageSize uint64)) *mAccessServiceMockGetListAccess {
	if mmGetListAccess.mock.inspectFuncGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("Inspect function is already set for AccessServiceMock.GetListAccess")
	}

	mmGetListAccess.mock.inspectFuncGetListAccess = f

	return mmGetListAccess
}

// Return sets up results that will be returned by AccessService.GetListAccess
func (mmGetListAccess *mAccessServiceMockGetListAccess) Return(apa1 []*model.Access, err error) *AccessServiceMock {
	if mmGetListAccess.mock.funcGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("AccessServiceMock.GetListAccess mock is already set by Set")
	}

	if mmGetListAccess.defaultExpectation == nil {
		mmGetListAccess.defaultExpectation = &AccessServiceMockGetListAccessExpectation{mock: mmGetListAccess.mock}
	}
	mmGetListAccess.defaultExpectation.results = &AccessServiceMockGetListAccessResults{apa1, err}
	return mmGetListAccess.mock
}

// Set uses given function f to mock the AccessService.GetListAccess method
func (mmGetListAccess *mAccessServiceMockGetListAccess) Set(f func(ctx context.Context, pageNumber uint64, pageSize uint64) (apa1 []*model.Access, err error)) *AccessServiceMock {
	if mmGetListAccess.defaultExpectation != nil {
		mmGetListAccess.mock.t.Fatalf("Default expectation is already set for the AccessService.GetListAccess method")
	}

	if len(mmGetListAccess.expectations) > 0 {
		mmGetListAccess.mock.t.Fatalf("Some expectations are already set for the AccessService.GetListAccess method")
	}

	mmGetListAccess.mock.funcGetListAccess = f
	return mmGetListAccess.mock
}

// When sets expectation for the AccessService.GetListAccess which will trigger the result defined by the following
// Then helper
func (mmGetListAccess *mAccessServiceMockGetListAccess) When(ctx context.Context, pageNumber uint64, pageSize uint64) *AccessServiceMockGetListAccessExpectation {
	if mmGetListAccess.mock.funcGetListAccess != nil {
		mmGetListAccess.mock.t.Fatalf("AccessServiceMock.GetListAccess mock is already set by Set")
	}

	expectation := &AccessServiceMockGetListAccessExpectation{
		mock:   mmGetListAccess.mock,
		params: &AccessServiceMockGetListAccessParams{ctx, pageNumber, pageSize},
	}
	mmGetListAccess.expectations = append(mmGetListAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessService.GetListAccess return parameters for the expectation previously defined by the When method
func (e *AccessServiceMockGetListAccessExpectation) Then(apa1 []*model.Access, err error) *AccessServiceMock {
	e.results = &AccessServiceMockGetListAccessResults{apa1, err}
	return e.mock
}

// GetListAccess implements service.AccessService
func (mmGetListAccess *AccessServiceMock) GetListAccess(ctx context.Context, pageNumber uint64, pageSize uint64) (apa1 []*model.Access, err error) {
	mm_atomic.AddUint64(&mmGetListAccess.beforeGetListAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListAccess.afterGetListAccessCounter, 1)

	if mmGetListAccess.inspectFuncGetListAccess != nil {
		mmGetListAccess.inspectFuncGetListAccess(ctx, pageNumber, pageSize)
	}

	mm_params := AccessServiceMockGetListAccessParams{ctx, pageNumber, pageSize}

	// Record call args
	mmGetListAccess.GetListAccessMock.mutex.Lock()
	mmGetListAccess.GetListAccessMock.callArgs = append(mmGetListAccess.GetListAccessMock.callArgs, &mm_params)
	mmGetListAccess.GetListAccessMock.mutex.Unlock()

	for _, e := range mmGetListAccess.GetListAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmGetListAccess.GetListAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListAccess.GetListAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListAccess.GetListAccessMock.defaultExpectation.params
		mm_got := AccessServiceMockGetListAccessParams{ctx, pageNumber, pageSize}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListAccess.t.Errorf("AccessServiceMock.GetListAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListAccess.GetListAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListAccess.t.Fatal("No results are set for the AccessServiceMock.GetListAccess")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmGetListAccess.funcGetListAccess != nil {
		return mmGetListAccess.funcGetListAccess(ctx, pageNumber, pageSize)
	}
	mmGetListAccess.t.Fatalf("Unexpected call to AccessServiceMock.GetListAccess. %v %v %v", ctx, pageNumber, pageSize)
	return
}

// GetListAccessAfterCounter returns a count of finished AccessServiceMock.GetListAccess invocations
func (mmGetListAccess *AccessServiceMock) GetListAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListAccess.afterGetListAccessCounter)
}

// GetListAccessBeforeCounter returns a count of AccessServiceMock.GetListAccess invocations
func (mmGetListAccess *AccessServiceMock) GetListAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListAccess.beforeGetListAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessServiceMock.GetListAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListAccess *mAccessServiceMockGetListAccess) Calls() []*AccessServiceMockGetListAccessParams {
	mmGetListAccess.mutex.RLock()

	argCopy := make([]*AccessServiceMockGetListAccessParams, len(mmGetListAccess.callArgs))
	copy(argCopy, mmGetListAccess.callArgs)

	mmGetListAccess.mutex.RUnlock()

	return argCopy
}

// MinimockGetListAccessDone returns true if the count of the GetListAccess invocations corresponds
// the number of defined expectations
func (m *AccessServiceMock) MinimockGetListAccessDone() bool {
	for _, e := range m.GetListAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListAccess != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetListAccessInspect logs each unmet expectation
func (m *AccessServiceMock) MinimockGetListAccessInspect() {
	for _, e := range m.GetListAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessServiceMock.GetListAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetListAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		if m.GetListAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessServiceMock.GetListAccess")
		} else {
			m.t.Errorf("Expected call to AccessServiceMock.GetListAccess with params: %#v", *m.GetListAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListAccess != nil && mm_atomic.LoadUint64(&m.afterGetListAccessCounter) < 1 {
		m.t.Error("Expected call to AccessServiceMock.GetListAccess")
	}
}

type mAccessServiceMockUpdateAccess struct {
	mock               *AccessServiceMock
	defaultExpectation *AccessServiceMockUpdateAccessExpectation
	expectations       []*AccessServiceMockUpdateAccessExpectation

	callArgs []*AccessServiceMockUpdateAccessParams
	mutex    sync.RWMutex
}

// AccessServiceMockUpdateAccessExpectation specifies expectation struct of the AccessService.UpdateAccess
type AccessServiceMockUpdateAccessExpectation struct {
	mock    *AccessServiceMock
	params  *AccessServiceMockUpdateAccessParams
	results *AccessServiceMockUpdateAccessResults
	Counter uint64
}

// AccessServiceMockUpdateAccessParams contains parameters of the AccessService.UpdateAccess
type AccessServiceMockUpdateAccessParams struct {
	ctx    context.Context
	access *model.Access
}

// AccessServiceMockUpdateAccessResults contains results of the AccessService.UpdateAccess
type AccessServiceMockUpdateAccessResults struct {
	err error
}

// Expect sets up expected params for AccessService.UpdateAccess
func (mmUpdateAccess *mAccessServiceMockUpdateAccess) Expect(ctx context.Context, access *model.Access) *mAccessServiceMockUpdateAccess {
	if mmUpdateAccess.mock.funcUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("AccessServiceMock.UpdateAccess mock is already set by Set")
	}

	if mmUpdateAccess.defaultExpectation == nil {
		mmUpdateAccess.defaultExpectation = &AccessServiceMockUpdateAccessExpectation{}
	}

	mmUpdateAccess.defaultExpectation.params = &AccessServiceMockUpdateAccessParams{ctx, access}
	for _, e := range mmUpdateAccess.expectations {
		if minimock.Equal(e.params, mmUpdateAccess.defaultExpectation.params) {
			mmUpdateAccess.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAccess.defaultExpectation.params)
		}
	}

	return mmUpdateAccess
}

// Inspect accepts an inspector function that has same arguments as the AccessService.UpdateAccess
func (mmUpdateAccess *mAccessServiceMockUpdateAccess) Inspect(f func(ctx context.Context, access *model.Access)) *mAccessServiceMockUpdateAccess {
	if mmUpdateAccess.mock.inspectFuncUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("Inspect function is already set for AccessServiceMock.UpdateAccess")
	}

	mmUpdateAccess.mock.inspectFuncUpdateAccess = f

	return mmUpdateAccess
}

// Return sets up results that will be returned by AccessService.UpdateAccess
func (mmUpdateAccess *mAccessServiceMockUpdateAccess) Return(err error) *AccessServiceMock {
	if mmUpdateAccess.mock.funcUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("AccessServiceMock.UpdateAccess mock is already set by Set")
	}

	if mmUpdateAccess.defaultExpectation == nil {
		mmUpdateAccess.defaultExpectation = &AccessServiceMockUpdateAccessExpectation{mock: mmUpdateAccess.mock}
	}
	mmUpdateAccess.defaultExpectation.results = &AccessServiceMockUpdateAccessResults{err}
	return mmUpdateAccess.mock
}

// Set uses given function f to mock the AccessService.UpdateAccess method
func (mmUpdateAccess *mAccessServiceMockUpdateAccess) Set(f func(ctx context.Context, access *model.Access) (err error)) *AccessServiceMock {
	if mmUpdateAccess.defaultExpectation != nil {
		mmUpdateAccess.mock.t.Fatalf("Default expectation is already set for the AccessService.UpdateAccess method")
	}

	if len(mmUpdateAccess.expectations) > 0 {
		mmUpdateAccess.mock.t.Fatalf("Some expectations are already set for the AccessService.UpdateAccess method")
	}

	mmUpdateAccess.mock.funcUpdateAccess = f
	return mmUpdateAccess.mock
}

// When sets expectation for the AccessService.UpdateAccess which will trigger the result defined by the following
// Then helper
func (mmUpdateAccess *mAccessServiceMockUpdateAccess) When(ctx context.Context, access *model.Access) *AccessServiceMockUpdateAccessExpectation {
	if mmUpdateAccess.mock.funcUpdateAccess != nil {
		mmUpdateAccess.mock.t.Fatalf("AccessServiceMock.UpdateAccess mock is already set by Set")
	}

	expectation := &AccessServiceMockUpdateAccessExpectation{
		mock:   mmUpdateAccess.mock,
		params: &AccessServiceMockUpdateAccessParams{ctx, access},
	}
	mmUpdateAccess.expectations = append(mmUpdateAccess.expectations, expectation)
	return expectation
}

// Then sets up AccessService.UpdateAccess return parameters for the expectation previously defined by the When method
func (e *AccessServiceMockUpdateAccessExpectation) Then(err error) *AccessServiceMock {
	e.results = &AccessServiceMockUpdateAccessResults{err}
	return e.mock
}

// UpdateAccess implements service.AccessService
func (mmUpdateAccess *AccessServiceMock) UpdateAccess(ctx context.Context, access *model.Access) (err error) {
	mm_atomic.AddUint64(&mmUpdateAccess.beforeUpdateAccessCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAccess.afterUpdateAccessCounter, 1)

	if mmUpdateAccess.inspectFuncUpdateAccess != nil {
		mmUpdateAccess.inspectFuncUpdateAccess(ctx, access)
	}

	mm_params := AccessServiceMockUpdateAccessParams{ctx, access}

	// Record call args
	mmUpdateAccess.UpdateAccessMock.mutex.Lock()
	mmUpdateAccess.UpdateAccessMock.callArgs = append(mmUpdateAccess.UpdateAccessMock.callArgs, &mm_params)
	mmUpdateAccess.UpdateAccessMock.mutex.Unlock()

	for _, e := range mmUpdateAccess.UpdateAccessMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateAccess.UpdateAccessMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAccess.UpdateAccessMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAccess.UpdateAccessMock.defaultExpectation.params
		mm_got := AccessServiceMockUpdateAccessParams{ctx, access}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAccess.t.Errorf("AccessServiceMock.UpdateAccess got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAccess.UpdateAccessMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAccess.t.Fatal("No results are set for the AccessServiceMock.UpdateAccess")
		}
		return (*mm_results).err
	}
	if mmUpdateAccess.funcUpdateAccess != nil {
		return mmUpdateAccess.funcUpdateAccess(ctx, access)
	}
	mmUpdateAccess.t.Fatalf("Unexpected call to AccessServiceMock.UpdateAccess. %v %v", ctx, access)
	return
}

// UpdateAccessAfterCounter returns a count of finished AccessServiceMock.UpdateAccess invocations
func (mmUpdateAccess *AccessServiceMock) UpdateAccessAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccess.afterUpdateAccessCounter)
}

// UpdateAccessBeforeCounter returns a count of AccessServiceMock.UpdateAccess invocations
func (mmUpdateAccess *AccessServiceMock) UpdateAccessBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAccess.beforeUpdateAccessCounter)
}

// Calls returns a list of arguments used in each call to AccessServiceMock.UpdateAccess.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAccess *mAccessServiceMockUpdateAccess) Calls() []*AccessServiceMockUpdateAccessParams {
	mmUpdateAccess.mutex.RLock()

	argCopy := make([]*AccessServiceMockUpdateAccessParams, len(mmUpdateAccess.callArgs))
	copy(argCopy, mmUpdateAccess.callArgs)

	mmUpdateAccess.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAccessDone returns true if the count of the UpdateAccess invocations corresponds
// the number of defined expectations
func (m *AccessServiceMock) MinimockUpdateAccessDone() bool {
	for _, e := range m.UpdateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccess != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateAccessInspect logs each unmet expectation
func (m *AccessServiceMock) MinimockUpdateAccessInspect() {
	for _, e := range m.UpdateAccessMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AccessServiceMock.UpdateAccess with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAccessMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		if m.UpdateAccessMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AccessServiceMock.UpdateAccess")
		} else {
			m.t.Errorf("Expected call to AccessServiceMock.UpdateAccess with params: %#v", *m.UpdateAccessMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAccess != nil && mm_atomic.LoadUint64(&m.afterUpdateAccessCounter) < 1 {
		m.t.Error("Expected call to AccessServiceMock.UpdateAccess")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AccessServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAccessibleRolesInspect()

			m.MinimockCheckInspect()

			m.MinimockCreateAccessInspect()

			m.MinimockDeleteAccessInspect()

			m.MinimockGetListAccessInspect()

			m.MinimockUpdateAccessInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AccessServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AccessServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccessibleRolesDone() &&
		m.MinimockCheckDone() &&
		m.MinimockCreateAccessDone() &&
		m.MinimockDeleteAccessDone() &&
		m.MinimockGetListAccessDone() &&
		m.MinimockUpdateAccessDone()
}
